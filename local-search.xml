<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>最佳（中高级）前端面试题</title>
    <link href="/2021/05/12/%E6%9C%80%E4%BD%B3%EF%BC%88%E4%B8%AD%E9%AB%98%E7%BA%A7%EF%BC%89%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2021/05/12/%E6%9C%80%E4%BD%B3%EF%BC%88%E4%B8%AD%E9%AB%98%E7%BA%A7%EF%BC%89%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>最佳（中高级）前端面试题（来自一个前端工程师）</p><h1>关于本文</h1><b>本文偏向很多算法的内容，并不很适合前端的初学者。如果你有2-3年的开发经验，且希望向架构、全栈等方向发展，这篇文章会很适合你。PS: 没有答案！这边篇文章是我在网上寻找面试题找到的，感觉自己好多都不会，想要记录一下，原文链接我会放在文末。</b><h1>前言</h1>本文具体就是大神Boris Cherny根据自己面试别人和被别人面试的经验，整理一份清单。我们面别人也好别人面我们也好，都有一些总会被提及的问题。下面提到的问题主要偏算法，不过很多公司都会关注你是否能写出高效的算法设计，比如一些大厂。问题主要分为一下几类：<ul><li><a href="#概念">概念</a></li><li><a href="#编码">编码</a><ul><li><a href="#简单">简单</a></li><li><a href="#中级">中级</a></li><li><a href="#困难">困难</a></li></ul></li><li><a href="#改错">改错</a></li><li><a href="#系统设计">系统设计</a></li><li><a href="#更多资料">更多资料</a></li></ul><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>请用清晰准确的语句解释如下名词（不需要编码）：</p><p>什么是“大O”符号，它被用来表示什么？</p><p>什么是DOM?</p><p>什么是时间循环？</p><p>什么是闭包？</p><p>原型继承是怎样的，如何工作，它和普通的继承有什么区别？(这个问题没啥意义，但很多面试官都爱问)</p><p>this 如何工作，代表什么?</p><p>什么是事件冒泡，它是如何工作的？（这也不是个好问题，同样的很多面试官很喜欢问。）</p><p>描述几种服务器和客户端之间的通信方式。描述一些网络协议是工作的（IP、TCP、http/S/2、UDP、RTC、DNS等）</p><p>REST是什么, 为什么使用它?</p><p>网页加载的很慢，诊断原因且修复它。如何进行性能优化，什么时候应该进行性能优化？</p><p>你用过什么前端框架？它们各有什么优缺点？为什么我们要使用框架？框架能为我们解决什么问题？</p><h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><p>实现以下功能：</p><h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><p>isPrime - 返回true或false, 表示输入的数是否为质数：</p><pre><code>isPrime(0)                          // false isPrime(1)                          // falseisPrime(17)                         // trueisPrime(10000000000000)             // false</code></pre><p>factorial - 返回给定数的阶乘的值：</p><pre><code>factorial(0)                        // 1factorial(1)                        // 1factorial(6)                        // 720</code></pre><p>fib -返回斐波那契数列的前n项的和（n为给定） <a href="https://en.wikipedia.org/wiki/Fibonacci_number" target="_blank" rel="noopener">斐波那契数列</a>.</p><pre><code>fib(0)                              // 0fib(1)                              // 1fib(10)                             // 55fib(20)                             // 6765</code></pre><p>isSorted - 返回true或false，表示给定的数组是否被排序过：</p><pre><code>isSorted([])                        // trueisSorted([-Infinity, -5, 0, 3, 9])  // trueisSorted([3, 9, -3, 10])            // false</code></pre><p>filter - 实现过滤器功能.</p><pre><code>filter([1, 2, 3, 4], n =&gt; n &lt; 3)    // [1, 2]</code></pre><p>reduce- 实现reduce 函数.</p><pre><code>reduce([1, 2, 3, 4], (a, b) =&gt; a + b, 0) // 10</code></pre><p>reverse- 反转给定字符串 (用已封装好的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" target="_blank" rel="noopener">reverse</a> 是一个cheat，要自己实现).</p><pre><code>reverse(&#39;&#39;)                         // &#39;&#39;reverse(&#39;abcdef&#39;)                   // &#39;fedcba&#39;</code></pre><p>indexOf - 实现数组的 indexOf方法.</p><pre><code>indexOf([1, 2, 3], 1)               // 0indexOf([1, 2, 3], 4)               // -1</code></pre><p>isPalindrome - 返回true或false判断给定字符串是否是一个回文(palindrome)（大小写不敏感）</p><pre><code>isPalindrome(&#39;&#39;)                                // trueisPalindrome(&#39;abcdcba&#39;)                         // trueisPalindrome(&#39;abcd&#39;)                            // falseisPalindrome(&#39;A man a plan a canal Panama&#39;)     // true</code></pre><p>missing - 一个数字1至n不重复且未排序过的数字组成的数组，从数字1至数字n选取出不重复且未排序过的数字组成数组（n为最大的数），调用方法后补全数组里缺失的数字。是否可以设计出时间复杂度为O(n)的算法？提示：有个聪明的方法供你使用。</p><pre><code>missing([])                         // undefinedmissing([1, 4, 3])                  // 2missing([2, 3, 4])                  // 1missing([5, 1, 4, 2])               // 3missing([1, 2, 3, 4])               // undefined</code></pre><p>isBalanced - 用true或false表示给定的字符串的花括号是否平衡（一一对应）</p><pre><code>isBalanced(&#39;}{&#39;)                      // falseisBalanced(&#39;{{}')                     // falseisBalanced('{}{}')                    // trueisBalanced('foo { bar { baz } boo }') // trueisBalanced('foo { bar { baz }')       // falseisBalanced('foo { bar } }')           // false```## 中级fib2 - 实现像上面的fib函数一样的功能，但是要能够算出数列中前50位以上的数的和。(小提示: 从内存中查询).```fib2(0)                               // 0fib2(1)                               // 1fib2(10)                              // 55fib2(50)                              // 12586269025```isBalanced2 - 实现同上面的isBalanced函数相同的功能，但是要支持三种类型的括号{}，[]，和()。带有交错括号的字符串应该返回false。```isBalanced2('(foo { bar (baz) [boo] })') // trueisBalanced2('foo { bar { baz }')         // falseisBalanced2('foo { (bar [baz] } )')      // false```uniq - 选取一个由数字组成的数组，为其去重，返回去重后的数组。可以实现出时间复杂度为O(n)的算法吗？```uniq([])                              // []uniq([1, 4, 2, 2, 3, 4, 8])           // [1, 4, 2, 3, 8]```intersection - 算出两个数组的交集（公共部分）。可以实现时间复杂度为O(M+N)（M和N为两个数组的长度）的方法吗？```intersection([1, 5, 4, 2], [8, 91, 4, 1, 3])    // [4, 1]intersection([1, 5, 4, 2], [7, 12])             // []```sort -实现 sort 方法，用于排序元素为数字的数组， 且时间复杂度为O(N×log(N)).```sort([])                              // []sort([-4, 1, Infinity, 3, 3, 0])      // [-4, 0, 1, 3, 3, Infinity]```includes - 判断给定的数字是否出现在给定的已排列好的数组中，返回true或false。是否能设计出时间复杂度为O(log(N))的算法？```includes([1, 3, 8, 10], 8)            // trueincludes([1, 3, 8, 8, 15], 15)        // trueincludes([1, 3, 8, 10, 15], 9)        // false```assignDeep- 仿照 Object.assign, 但是要深度合并对象。为了简单起见，可以假设对象只包含数字或是什么别的（而不是数组、函数等）。```assignDeep({ a: 1 }, {})              // { a: 1 }assignDeep({ a: 1 }, { a: 2 })        // { a: 2 }assignDeep({ a: 1 }, { a: { b: 2 } }) // { a: { b: 2 } }assignDeep({ a: { b: { c: 1 }}}, { a: { b: { d: 2 }}, e: 3 })// { a: { b: { c: 1, d: 2 }}, e: 3 }</code></pre><p>reduceAsync- 仿照reduce 你在“简单”部分中完成了，但每个条目都必须在进行下一步之前被解决。</p><pre><code>let a = () =&gt; Promise.resolve(&#39;a&#39;)let b = () =&gt; Promise.resolve(&#39;b&#39;)let c = () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(&#39;c&#39;), 100))await reduceAsync([a, b, c], (acc, value) =&gt; [...acc, value], []) // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]await reduceAsync([a, c, b], (acc, value) =&gt; [...acc, value], [&#39;d&#39;])// [&#39;d&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;]</code></pre><p>用reduceAsync来实现seq。seq使用一个可返回 promise的函数体内使用数组的函数，然后逐一的解决。</p><pre><code>let a = () =&gt; Promise.resolve(&#39;a&#39;)let b = () =&gt; Promise.resolve(&#39;b&#39;)let c = () =&gt; Promise.resolve(&#39;c&#39;)await seq([a, b, c])                  // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]await seq([a, c, b])                  // [&#39;a&#39;, &#39;c&#39;, &#39;b&#39;]</code></pre><h2 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h2><p>注意：下面你要实现的数据结构问题，意不在让你记住它们，而只是希望你去查看给出的API，Google是怎么考虑且实现它们的，然后站在一个较高的角度去思考这些实现和其他数据结构相比如何。</p><p>permute - 返回一个字符串数组，包含给定的字符串的所有的排列。</p><pre><code>permute(&#39;&#39;)             // []permute(&#39;abc&#39;)          // [&#39;abc&#39;, &#39;acb&#39;, &#39;bac&#39;, &#39;bca&#39;, &#39;cab&#39;, &#39;cba&#39;]</code></pre><p>debounce - 实现 debounce 函数.</p><pre><code>let a = () =&gt; console.log(&#39;foo&#39;)let b = debounce(a, 100)b()b()b() // only this call should invoke a()</code></pre><p>实现一个 LinkedList 类，不用 JavaScript的built-in 数组 ([]). 你的链表需要支持两种方法，add和has。</p><pre><code>class LinkedList {...}let list = new LinkedList(1, 2, 3)list.add(4)                           // undefinedlist.add(5)                           // undefinedlist.has(1)                           // truelist.has(4)                           // truelist.has(6)                           // false</code></pre><p>实现一个HashMap 类，不用JavaScript的built-in objects ({}) 方法或者是Maps方法。你需要提供一个hash()函数，传入一个字符串，返回一个数字（大多数情况下数字都是唯一的，有时候两个不同的字符串会返回一样的数字）：</p><pre><code>function hash (string) {      return string    .split(&#39;&#39;)    .reduce((a, b) =&gt; ((a &lt;&lt; 5) + a) + b.charCodeAt(0), 5381)}</code></pre><p>你有的哈希表需要支持两种方法，get和set:</p><pre><code>let map = new HashMapmap.set(&#39;abc&#39;, 123)                   // undefinedmap.set(&#39;foo&#39;, &#39;bar&#39;)                 // undefinedmap.set(&#39;foo&#39;, &#39;baz&#39;)                 // undefinedmap.get(&#39;abc&#39;)                        // 123map.get(&#39;foo&#39;)                        // &#39;baz&#39;map.get(&#39;def&#39;)                        // undefined</code></pre><p>实现一个BinarySearchTree（二叉搜索树）类，需要支持四种方法：add，has，remove， size：</p><pre><code>let tree = new BinarySearchTreetree.add(1, 2, 3, 4)tree.add(5)tree.has(2)                           // truetree.has(5)                           // truetree.remove(3)                        // undefinedtree.size()                           // 4</code></pre><p>实现一个BinaryTree（二叉树）类，广度优先搜索、中序排列、先序排列、后序遍历深度优先搜索功能。</p><pre><code>let tree = new BinaryTreelet fn = value =&gt; console.log(value)tree.add(1, 2, 3, 4)tree.bfs(fn)                          // undefinedtree.inorder(fn)                      // undefinedtree.preorder(fn)                     // undefinedtree.postorder(fn)                    // undefined</code></pre><h1 id="改错"><a href="#改错" class="headerlink" title="改错"></a>改错</h1><p>下面的每一个问题，先要弄明白为什么给出的代码块无法正常实现功能，然后想出解决方案，编写代码，正常实现功能：</p><p>我想要代码打印出：“hey amy”，但是它打印的是“hey arnold”，为什么呢？</p><pre><code>function greet(person) {      if (person == { name: &#39;amy&#39; }) {            return &#39;hey amy&#39;    } else {          return &#39;hey arnold&#39;    }}greet({ name: &#39;amy&#39; })</code></pre><p>我希望代码按顺序打印出数字0，1，2，3，但是现在并不是这样的输出（这一度被认为是一个小bug，很多人喜欢在面试的时候提问为什么）</p><pre><code>for (var i = 0; i &lt; 4; i++) {  setTimeout(() =&gt; console.log(i), 0)}</code></pre><p>我希望代码打印出“doggo”，但是现在打出来是undefined</p><pre><code>let dog = {  name: &#39;doggo&#39;,  sayName() {    console.log(this.name)  }}let sayName = dog.sayNamesayName()</code></pre><p>我想要我的狗狗bark()，但是我得到的确实error，为什么呢？</p><pre><code>function Dog(name) {      this.name = name}Dog.bark = function() {      console.log(this.name + &#39; says woof&#39;)}let fido = new Dog(&#39;fido&#39;)fido.bark()</code></pre><p>为什么这个代码会返回这样结果？</p><pre><code>function isBig(thing) {    if (thing == 0 || thing == 1 || thing == 2) {            return false  }    return true}isBig(1)    // falseisBig([2])  // falseisBig([3])  // true</code></pre><h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><p>如果你不是很明白“系统设计”，你可以从<a href="https://github.com/donnemartin/system-design-primer" target="_blank" rel="noopener">这里</a>开始学习。</p><p>来聊聊看，如果想要做一个完整的自动补全的小程序(widget)。用户可以在其中输入文字，并从服务器得到返回结果。</p><p>你会如何设计一个支持以下功能的前端页面：</p><ol><li><p>从后台API获取数据</p></li><li><p>以树形渲染结果（每个对象可以有父/子，而不是一个平铺的列表）</p></li><li><p>支持checkbox, radio button, icon以及普通的列表项-列表项从很多的表单中得到</p></li></ol><p>组件API是怎样的？<br>后端API是怎样的？<br>对于补全输入的行为还有什么会影响到性能的事是要额外考虑进去的？是否有一些边缘情况发生（比如如果用户输入速度快，网络速度慢）？<br>若要前端展现更加迅速，你会怎么设计网络部分以及架构后端？你的客户端和服务器是怎样通信的？后端的数据如何存储？当扩展到有大量数据和大量客户时，如何实现这些功能？</p><p>谈谈如何实现Twitter的全栈构建（从我的朋友<a href="https://github.com/blaisebaileyfinnegan" target="_blank" rel="noopener">Michael Vu</a>那窃来的题目，害羞）。<br>如何获取并渲染每条推特消息？<br>当有新的推文来了你该如何渲染？你如何知道啥时候来了新的推文？<br>你该如何设计搜索推文？如何按作者搜索推文？聊聊你的数据库、后台以及API设计。</p><h1 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h1><p>如果你这些都了解了想要了解更多知识，下面有一些我找到的更高质量的资源也许对你有帮助。</p><p>有帮助的项目：</p><p><a href="https://smile.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1848000693" target="_blank" rel="noopener">The Algorithm Design Manual</a></p><p><a href="https://code.google.com/codejam/past-contests" target="_blank" rel="noopener">Past CodeJam problems</a></p><p><a href="https://github.com/keon/algorithms" target="_blank" rel="noopener">keon/algorithms</a></p><p>有帮助的书籍：</p><p><a href="https://smile.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1848000693" target="_blank" rel="noopener">The Algorithm Design Manual</a>  算法设计手册</p><p><a href="https://leanpub.com/javascriptallongesix/read" target="_blank" rel="noopener">JavaScript Allonge</a> JavaScript附录</p><p><a href="https://github.com/getify/You-Dont-Know-JS" target="_blank" rel="noopener">You Don’t Know JS</a> 你不知道的JavaScript</p><p><a href="https://smile.amazon.com/Effective-JavaScript-Specific-Software-Development/dp/0321812182" target="_blank" rel="noopener">Effective JavaScript</a> 高效的JavaScript</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端收藏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript第三天</title>
    <link href="/2021/05/11/JavaScript%E7%AC%AC%E4%B8%89%E5%A4%A9/"/>
    <url>/2021/05/11/JavaScript%E7%AC%AC%E4%B8%89%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<p>开始学习挑战30天JavaScript的第三天。</p><h1 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h1><p>布尔数据类型表示两个值之一：true或false。 布尔值是true或false。 当您启动比较运算符时，将清楚使用这些数据类型。 任何比较都会返回一个布尔值，该布尔值可以为true或false。<br>示例：</p><pre><code>let isLightOn = truelet isRaining = falselet truValue = 4 &gt; 3    // truelet falseValue = 4 &lt; 3  // false</code></pre><p>注意：</p><ol><li>除零外，所有数字（正数和负数）都是true</li><li>所有的字符串都是true</li><li>布尔值true</li></ol><h1 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h1><p>如果我们声明一个变量并且不分配值，则该值将是不确定的。 除此之外，如果一个函数没有返回值，它将是Undefined值</p><h1 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h1><p>空值</p><h1 id="算术运算符的数学运算符。"><a href="#算术运算符的数学运算符。" class="headerlink" title="算术运算符的数学运算符。"></a>算术运算符的数学运算符。</h1><ol><li>加（+）：a + b</li><li>减法（-）：a-b</li><li>乘法（*）：a * b</li><li>除（/）：a / b</li><li>模量（％）：a％b</li><li>指数（*<em>）：a *</em> b</li></ol><pre><code>let numOne = 4let numTwo = 3let sum = numOne + numTwolet diff = numOne - numTwolet mult = numOne * numTwolet div = numOne / numTwolet remainder = numOne % numTwolet powerOf = numOne ** numTwoconsole.log(sum, diff, mult, div, remainder, powerOf) // 7,1,12,1.33,1, 64</code></pre><h1 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h1><p>在编程中，我们比较值，我们使用比较运算符比较两个值。 我们检查一个值是大于还是小于或等于其他值。</p><pre><code>console.log(3 &gt; 2)              // true, because 3 is greater than 2console.log(3 &gt;= 2)             // true, because 3 is greater than 2console.log(3 &lt; 2)              // false,  because 3 is greater than 2console.log(2 &lt; 3)              // true, because 2 is less than 3console.log(2 &lt;= 3)             // true, because 2 is less than 3console.log(3 == 2)             // false, because 3 is not equal to 2console.log(3 != 2)             // true, because 3 is not equal to 2console.log(3 == &#39;3&#39;)           // true, compare only valueconsole.log(3 === &#39;3&#39;)          // false, compare both value and data typeconsole.log(3 !== &#39;3&#39;)          // true, compare both value and data typeconsole.log(3 != 3)             // false, compare only valueconsole.log(3 !== 3)            // false, compare both value and data typeconsole.log(0 == false)         // true, equivalentconsole.log(0 === false)        // false, not exactly the sameconsole.log(0 == &#39;&#39;)            // true, equivalentconsole.log(0 == &#39; &#39;)           // true, equivalentconsole.log(0 === &#39;&#39;)           // false, not exactly the sameconsole.log(1 == true)          // true, equivalentconsole.log(1 === true)         // false, not exactly the sameconsole.log(undefined == null)  // trueconsole.log(undefined === null) // falseconsole.log(NaN == NaN)         // false, not equalconsole.log(NaN === NaN)        // falseconsole.log(typeof NaN)         // numberconsole.log(&#39;mango&#39;.length == &#39;avocado&#39;.length)  // falseconsole.log(&#39;mango&#39;.length != &#39;avocado&#39;.length)  // trueconsole.log(&#39;mango&#39;.length &lt; &#39;avocado&#39;.length)   // trueconsole.log(&#39;milk&#39;.length == &#39;meat&#39;.length)      // trueconsole.log(&#39;milk&#39;.length != &#39;meat&#39;.length)      // falseconsole.log(&#39;tomato&#39;.length == &#39;potato&#39;.length)  // trueconsole.log(&#39;python&#39;.length &gt; &#39;dragon&#39;.length)   // false</code></pre><h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><p>以下符号是常见的逻辑运算符：&amp;&amp;（＆）和||（pipe）和！（negation）。 仅当两个操作数为true时，&amp;&amp;运算符才为true。 || 运算符为true，则任一操作数为true。 这 ！ 运算符否定“真到假”和“假到真”。</p><pre><code>// &amp;&amp; ampersand operator exampleconst check = 4 &gt; 3 &amp;&amp; 10 &gt; 5         // true &amp;&amp; true -&gt; trueconst check = 4 &gt; 3 &amp;&amp; 10 &lt; 5         // true &amp;&amp; false -&gt; falseconst check = 4 &lt; 3 &amp;&amp; 10 &lt; 5         // false &amp;&amp; false -&gt; false// || pipe or operator, exampleconst check = 4 &gt; 3 || 10 &gt; 5         // true  || true -&gt; trueconst check = 4 &gt; 3 || 10 &lt; 5         // true  || false -&gt; trueconst check = 4 &lt; 3 || 10 &lt; 5         // false || false -&gt; false//! Negation exampleslet check = 4 &gt; 3                     // truelet check = !(4 &gt; 3)                  //  falselet isLightOn = truelet isLightOff = !isLightOn           // falselet isMarried = !false                // true</code></pre><h1 id="增量运算符"><a href="#增量运算符" class="headerlink" title="增量运算符"></a>增量运算符</h1><p>在JavaScrip中，我们使用增量运算符来增加存储在变量中的值。 该增量可以是之前或之后的增量。 让我们看看它们中的每一个：</p><ol><li>前置递增</li></ol><pre><code>let count = 0console.log(++count)        // 1console.log(count)          // 1</code></pre><ol start="2"><li>后置递增</li></ol><pre><code>let count = 0console.log(count++)        // 0console.log(count)          // 1</code></pre><p>大多数情况下，我们使用增量后的时间。 至少您应该记住如何使用后增量运算符。</p><h1 id="递减运算符"><a href="#递减运算符" class="headerlink" title="递减运算符"></a>递减运算符</h1><p>在JavaScrip中，我们使用减量运算符来减小存储在变量中的值。 减量可以是前减量，也可以是后减量。 让我们看看它们中的每一个：</p><ol><li>前置递减</li></ol><pre><code>let count = 0console.log(--count) // -1console.log(count)  // -1</code></pre><ol start="2"><li>后置递减</li></ol><pre><code>let count = 0console.log(count--) // 0console.log(count)   // -1</code></pre><h1 id="三目运算"><a href="#三目运算" class="headerlink" title="三目运算"></a>三目运算</h1><p>三元运算符允许编写条件。 编写条件语句的另一种方法是使用三元运算符。 看下面的例子：</p><pre><code>let isRaining = trueisRaining  ? console.log(&#39;You need a rain coat.&#39;)  : console.log(&#39;No need for a rain coat.&#39;)isRaining = falseisRaining  ? console.log(&#39;You need a rain coat.&#39;)  : console.log(&#39;No need for a rain coat.&#39;)</code></pre><h1 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h1><p>我想建议您从此<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">链接</a>阅读有关操作员优先级的信息</p><h1 id="window-内置方法"><a href="#window-内置方法" class="headerlink" title="window 内置方法"></a>window 内置方法</h1><h2 id="window-alert"><a href="#window-alert" class="headerlink" title="window.alert()"></a>window.alert()</h2><p>如您刚开始看到的那样，alert（）方法将显示一个带有指定消息和“确定”按钮的警报框。 这是一个内置方法，它带有参数。</p><pre><code>alert(message)</code></pre><p>不要使用过多的警报，因为它会造成破坏和烦人，请仅将其用于测试。</p><h2 id="window-prompt"><a href="#window-prompt" class="headerlink" title="window.prompt();"></a>window.prompt();</h2><p>窗口提示方法在浏览器上显示一个带有输入的提示框，以获取输入值，并且输入数据可以存储在变量中。 tips（）方法有两个参数。 第二个参数是可选的。</p><pre><code>prompt(&#39;required text&#39;, &#39;optional text&#39;)</code></pre><h2 id="window-confirm"><a href="#window-confirm" class="headerlink" title="window.confirm()"></a>window.confirm()</h2><p>Confirm（）方法将显示一个对话框，其中包含指定的消息以及“确定”和“取消”按钮。 确认框通常用于请求用户许可以执行某些操作。 窗口confirm（）将字符串作为参数。 单击“确定”将产生真值，而单击“取消”按钮将产生假值。</p><pre><code>const agree = confirm(&#39;Are you sure you like to delete? &#39;)console.log(agree) // result will be true or false based on what you click on the dialog box</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript的30天基础巩固</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript第二天</title>
    <link href="/2021/05/10/JavaScript%E7%AC%AC%E4%BA%8C%E5%A4%A9/"/>
    <url>/2021/05/10/JavaScript%E7%AC%AC%E4%BA%8C%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<p>开始学习挑战30天JavaScript的第二天。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>在上一节中，我们提到了一些有关数据类型的内容。 数据或值具有数据类型。 数据类型描述了数据的特征。 数据类型可以分为两种：</p><ol><li>原始数据类型</li><li>非原始数据类型（对象引用）</li></ol><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>JavaScript中的基本数据类型包括：</p><ol><li>Number 数字-整数，浮点数</li><li>String 字符串-单引号，双引号或反引号下的任何数据</li><li>Boolean 布尔值-真或假值</li><li>Null 空-空值或无值</li><li>Undefined 未定义-没有值的声明变量</li></ol><p>JavaScript中的非基本数据类型包括:</p><ol><li>Object</li><li>Function</li><li>Arrays</li></ol><p>现在，让我们看看基本和非基本数据类型的确切含义。 基本数据类型是不可变（不可修改）数据类型。 创建原始数据类型后，我们将无法对其进行修改。<br>示例</p><pre><code>let word = &#39;JavaScript&#39;;</code></pre><p>如果我们尝试修改存储在可变字中的字符串，则JavaScript应该引发错误。 单引号，双引号或反引号下的任何数据类型都是字符串数据类型。</p><pre><code>word[0] = &#39;Y&#39;;</code></pre><p>此表达式不会更改存储在变量字中的字符串。 因此，我们可以说字符串是不可修改的，或者说是不可更改的。 通过其值比较原始数据类型。 让我们比较不同的数据值。 请参见下面的示例：</p><pre><code>let numOne = 3let numTwo = 3console.log(numOne == numTwo)      // truelet js = &#39;JavaScript&#39;let py = &#39;Python&#39;console.log(js == py)             //false let lightOn = truelet lightOff = falseconsole.log(lightOn == lightOff) // false</code></pre><h1 id="非基本数据类型"><a href="#非基本数据类型" class="headerlink" title="非基本数据类型"></a>非基本数据类型</h1><p>非基本数据类型是可修改或可变的。 创建非基本数据类型后，我们可以对其进行修改。 让我们通过创建一个数组来看看。 数组是方括号中的数据值列表。 数组可以包含相同或不同的数据类型。 数组值由其索引引用。 在JavaScript中，数组索引从零开始。 即，数组的第一个元素位于索引零，第二个元素位于索引一，第三个元素位于索引二，依此类推。</p><pre><code>let nums = [1, 2, 3]nums[0] = 10console.log(nums)  // [10, 2, 3]</code></pre><p>如您所见，作为非基本数据类型的数组是可变的。 非基本数据类型无法按值进行比较。 即使两个非基本数据类型具有相同的属性和值，它们也不是严格相等的。</p><pre><code>let nums = [1, 2, 3]let numbers = [1, 2, 3]console.log(nums == numbers)  // falselet userOne = {name:&#39;Asabeneh&#39;,role:&#39;teaching&#39;,country:&#39;Finland&#39;}let userTwo = {name:&#39;Asabeneh&#39;,role:&#39;teaching&#39;,country:&#39;Finland&#39;}console.log(userOne == userTwo) // false</code></pre><p>根据经验，我们不比较非基本数据类型。 不要比较数组，函数或对象。 非基本值称为引用类型，因为它们是通过引用而不是值进行比较的。 如果两个对象引用相同的基础对象，则它们严格相等。</p><pre><code>let nums = [1, 2, 3]let numbers = numsconsole.log(nums == numbers)  // truelet userOne = {name:&#39;Asabeneh&#39;,role:&#39;teaching&#39;,country:&#39;Finland&#39;}let userTwo = userOneconsole.log(userOne == userTwo)  // true</code></pre><p>如果您很难理解基本数据类型和非基本数据类型之间的区别，那么您不是唯一的人。 冷静下来，然后转到下一部分，尝试在一段时间后再回来。 现在让我们从数字类型开始数据类型。</p><h1 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h1><p>数字是可以执行所有算术运算的整数和十进制值。 让我们看一些数字的例子。</p><h2 id="声明数据类型"><a href="#声明数据类型" class="headerlink" title="声明数据类型"></a>声明数据类型</h2><pre><code>let age = 35const gravity = 9.81  // we use const for non-changing values, gravitational constant in  m/s2let mass = 72         // mass in Kilogramconst PI = 3.14       // pi a geometrical constant// More Examplesconst boilingPoint = 100 // temperature in oC, boiling point of water which is a constantconst bodyTemp = 37      // oC average human body temperature, which is a constantconsole.log(age, gravity, mass, PI, boilingPoint, bodyTemp)</code></pre><h1 id="数学对象"><a href="#数学对象" class="headerlink" title="数学对象"></a>数学对象</h1><p>在JavaScript中，数学对象提供了许多处理数字的方法。</p><pre><code>const PI = Math.PIconsole.log(PI)                            // 3.141592653589793// Rounding to the closest number// if above .5 up if less 0.5 down roundingconsole.log(Math.round(PI))                // 3 to round values to the nearest numberconsole.log(Math.round(9.81))              // 10console.log(Math.floor(PI))                // 3 rounding downconsole.log(Math.ceil(PI))                 // 4 rounding upconsole.log(Math.min(-5, 3, 20, 4, 5, 10)) // -5, returns the minimum valueconsole.log(Math.max(-5, 3, 20, 4, 5, 10)) // 20, returns the maximum valueconst randNum = Math.random() // creates random number between 0 to 0.999999console.log(randNum)// Let us  create random number between 0 to 10const num = Math.floor(Math.random () * 11) // creates random number between 0 and 10console.log(num)//Absolute valueconsole.log(Math.abs(-10))      // 10//Square rootconsole.log(Math.sqrt(100))     // 10console.log(Math.sqrt(2))       // 1.4142135623730951// Powerconsole.log(Math.pow(3, 2))     // 9console.log(Math.E)             // 2.718// Logarithm// Returns the natural logarithm with base E of x, Math.log(x)console.log(Math.log(2))        // 0.6931471805599453console.log(Math.log(10))       // 2.302585092994046// TrigonometryMath.sin(0)Math.sin(60)Math.cos(0)Math.cos(60)</code></pre><h1 id="随机数生成器"><a href="#随机数生成器" class="headerlink" title="随机数生成器"></a>随机数生成器</h1><p>JavaScript Math对象具有一个random()方法数字生成器，该生成器生成从0到0.999999999的数字。</p><pre><code>let randomNum = Math.random() // generates 0 to 0.999...</code></pre><p>现在，让我们看看如何使用random（）方法生成介于0到10之间的随机数：</p><pre><code>let randomNum = Math.random()         // generates 0 to 0.999let numBtnZeroAndTen = randomNum * 11console.log(numBtnZeroAndTen)         // this gives: min 0 and max 10.99let randomNumRoundToFloor = Math.floor(numBtnZeroAndTen)console.log(randomNumRoundToFloor)    // this gives between 0 and 10</code></pre><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>字符串是文本，用单引号，双引号和反引号引起来。 要声明字符串，我们需要一个变量名，赋值运算符，单引号，双引号或反引号下的值。 让我们看一些字符串示例：</p><pre><code>let space = &#39; &#39;           // an empty space stringlet firstName = &#39;Asabeneh&#39;let lastName = &#39;Yetayeh&#39;let country = &#39;Finland&#39;let city = &#39;Helsinki&#39;let language = &#39;JavaScript&#39;let job = &#39;teacher&#39;let quote = &quot;The saying,&#39;Seeing is Believing&#39; is not correct in 2020.&quot;let quotWithBackTick = `The saying,&#39;Seeing is Believing&#39; is not correct in 2020.`</code></pre><h1 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h1><p>将两个或多个字符串连接在一起称为串联。 使用前面的“字符串”部分中声明的字符串：</p><pre><code>let fullName = firstName + space + lastName; // concatenation, merging two string together.console.log(fullName);</code></pre><p>我们可以用不同的方式连接字符串。</p><h2 id="串联使用加法运算符"><a href="#串联使用加法运算符" class="headerlink" title="串联使用加法运算符"></a>串联使用加法运算符</h2><p>使用加法运算符进行连接是一种旧方法。 这种连接方式既繁琐又容易出错。 很高兴知道如何以这种方式进行连接，但是我强烈建议使用ES6模板字符串（稍后说明）</p><pre><code>// Declaring different variables of different data typeslet space = &#39; &#39;let firstName = &#39;Asabeneh&#39;let lastName = &#39;Yetayeh&#39;let country = &#39;Finland&#39;let city = &#39;Helsinki&#39;let language = &#39;JavaScript&#39;let job = &#39;teacher&#39;let age = 250let fullName =firstName + space + lastNamelet personInfoOne = fullName + &#39;. I am &#39; + age + &#39;. I live in &#39; + country; // ES5 string additionconsole.log(personInfoOne)</code></pre><h1 id="长文本字符串"><a href="#长文本字符串" class="headerlink" title="长文本字符串"></a>长文本字符串</h1><p>字符串可以是单个字符或段落或页面。 如果字符串长度太大，则它不能排成一行。 我们可以在每一行的末尾使用反斜杠字符（\）来指示该字符串将在下一行继续。 例子：</p><pre><code>const paragraph = &quot;My name is Asabeneh Yetayeh. I live in Finland, Helsinki.\I am a teacher and I love teaching. I teach HTML, CSS, JavaScript, React, Redux, \Node.js, Python, Data Analysis and D3.js for anyone who is interested to learn. \In the end of 2019, I was thinking to expand my teaching and to reach \to global audience and I started a Python challenge from November 20 - December 19.\It was one of the most rewarding and inspiring experience.\Now, we are in 2020. I am enjoying preparing the 30DaysOfJavaScript challenge and \I hope you are enjoying too.&quot;console.log(paragraph)</code></pre><h1 id="字符串中的转义序列"><a href="#字符串中的转义序列" class="headerlink" title="字符串中的转义序列"></a>字符串中的转义序列</h1><p>在JavaScript和其他编程语言中，\后跟一些字符是转义序列。 让我们看看最常见的转义字符：</p><ol><li>\n: 换行</li><li>\t: 制表符，表示8个空格</li><li>\: 反斜线</li><li>&#39;: 单引号 (‘)</li><li>&quot;: 双引号 (“)</li></ol><pre><code>console.log(&#39;I hope everyone is enjoying the 30 Days Of JavaScript challenge.\nDo you ?&#39;) // line breakconsole.log(&#39;Days\tTopics\tExercises&#39;)console.log(&#39;Day 1\t3\t5&#39;)console.log(&#39;Day 2\t3\t5&#39;)console.log(&#39;Day 3\t3\t5&#39;)console.log(&#39;Day 4\t3\t5&#39;)console.log(&#39;This is a backslash  symbol (\\)&#39;) // To write a backslashconsole.log(&#39;In every programming language it starts with \&quot;Hello, World!\&quot;&#39;)console.log(&quot;In every programming language it starts with \&#39;Hello, World!\&#39;&quot;)console.log(&#39;The saying \&#39;Seeing is Believing\&#39; isn\&#39;t correct in 2020&#39;)</code></pre><h1 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h1><p>要创建模板字符串，我们使用两个反引号。 我们可以将数据作为表达式插入模板字符串中。 要注入数据，我们在表达式前用大括号（{}）括起$符号。 请参见下面的语法。</p><pre><code>//Syntax`String literal text``String literal text ${expression}`</code></pre><p>示例1：</p><pre><code>console.log(`The sum of 2 and 3 is 5`)              // statically writing the datalet a = 2let b = 3console.log(`The sum of ${a} and ${b} is ${a + b}`) // injecting the data dynamically</code></pre><p>示例2：</p><pre><code>let firstName = &#39;Asabeneh&#39;let lastName = &#39;Yetayeh&#39;let country = &#39;Finland&#39;let city = &#39;Helsinki&#39;let language = &#39;JavaScript&#39;let job = &#39;teacher&#39;let age = 250let fullName = firstName + &#39; &#39; + lastNamelet personInfoTwo = `I am ${fullName}. I am ${age}. I live in ${country}.` //ES6 - String interpolation methodlet personInfoThree = `I am ${fullName}. I live in ${city}, ${country}. I am a ${job}. I teach ${language}.`console.log(personInfoTwo)console.log(personInfoThree)</code></pre><p>使用字符串模板或字符串插值方法，我们可以添加表达式，它可以是一个值或某些运算（比较，算术运算，三进制运算）。</p><pre><code>let a = 2let b = 3console.log(`${a} is greater than ${b}: ${a &gt; b}`)</code></pre><h1 id="字符串内置方法"><a href="#字符串内置方法" class="headerlink" title="字符串内置方法"></a>字符串内置方法</h1><p>JavaScript中的所有内容都是一个对象。 字符串是原始数据类型，这意味着一旦创建它便无法对其进行修改。 字符串对象有许多字符串方法。 有许多不同的字符串方法可以帮助我们处理字符串。</p><h2 id="length：字符串长度方法返回字符串中包含空格的字符数。"><a href="#length：字符串长度方法返回字符串中包含空格的字符数。" class="headerlink" title="length：字符串长度方法返回字符串中包含空格的字符数。"></a>length：字符串长度方法返回字符串中包含空格的字符数。</h2><p>示例：</p><pre><code>let js = &#39;JavaScript&#39;console.log(js.length)         // 10let firstName = &#39;Asabeneh&#39;console.log(firstName.length)  // 8</code></pre><p>访问字符串中的字符：我们可以使用其索引访问字符串中的每个字符。 在编程中，计数从0开始。字符串的第一个索引为零，最后一个索引为字符串的长度减一。</p><p>让我们访问“ JavaScript”字符串中的不同字符。</p><pre><code>let string = &#39;JavaScript&#39;let firstLetter = string[0]console.log(firstLetter)           // Jlet secondLetter = string[1]       // alet thirdLetter = string[2]let lastLetter = string[9]console.log(lastLetter)            // tlet lastIndex = string.length - 1console.log(lastIndex)  // 9console.log(string[lastIndex])    // t</code></pre><h2 id="toUpperCase（）：此方法将字符串更改为大写字母。"><a href="#toUpperCase（）：此方法将字符串更改为大写字母。" class="headerlink" title="toUpperCase（）：此方法将字符串更改为大写字母。"></a>toUpperCase（）：此方法将字符串更改为大写字母。</h2><pre><code>let string = &#39;JavaScript&#39;console.log(string.toUpperCase())     // JAVASCRIPTlet firstName = &#39;Asabeneh&#39;console.log(firstName.toUpperCase())  // ASABENEHlet country = &#39;Finland&#39;console.log(country.toUpperCase())    // FINLAND</code></pre><h2 id="toLowerCase（）：此方法将字符串更改为小写字母。"><a href="#toLowerCase（）：此方法将字符串更改为小写字母。" class="headerlink" title="toLowerCase（）：此方法将字符串更改为小写字母。"></a>toLowerCase（）：此方法将字符串更改为小写字母。</h2><pre><code>let string = &#39;JavasCript&#39;console.log(string.toLowerCase())     // javascriptlet firstName = &#39;Asabeneh&#39;console.log(firstName.toLowerCase())  // asabenehlet country = &#39;Finland&#39;console.log(country.toLowerCase())   // finland</code></pre><h2 id="substr（）：它有两个参数，起始索引和要分割的字符数。"><a href="#substr（）：它有两个参数，起始索引和要分割的字符数。" class="headerlink" title="substr（）：它有两个参数，起始索引和要分割的字符数。"></a>substr（）：它有两个参数，起始索引和要分割的字符数。</h2><pre><code>let string = &#39;JavaScript&#39;console.log(string.substr(4,6))    // Scriptlet country = &#39;Finland&#39;console.log(country.substr(3, 4))   // land</code></pre><h2 id="substring（）：它接受两个参数，即起始索引和终止索引，但不包含终止索引处的字符。"><a href="#substring（）：它接受两个参数，即起始索引和终止索引，但不包含终止索引处的字符。" class="headerlink" title="substring（）：它接受两个参数，即起始索引和终止索引，但不包含终止索引处的字符。"></a>substring（）：它接受两个参数，即起始索引和终止索引，但不包含终止索引处的字符。</h2><pre><code>let string = &#39;JavaScript&#39;console.log(string.substring(0,4))     // Javaconsole.log(string.substring(4,10))    // Scriptconsole.log(string.substring(4))       // Scriptlet country = &#39;Finland&#39;console.log(country.substring(0, 3))   // Finconsole.log(country.substring(3, 7))   // landconsole.log(country.substring(3))      // land</code></pre><h2 id="split（）：split方法在指定位置分割字符串。"><a href="#split（）：split方法在指定位置分割字符串。" class="headerlink" title="split（）：split方法在指定位置分割字符串。"></a>split（）：split方法在指定位置分割字符串。</h2><pre><code>let string = &#39;30 Days Of JavaScript&#39;console.log(string.split())     // Changes to an array -&gt; [&quot;30 Days Of JavaScript&quot;]console.log(string.split(&#39; &#39;))  // Split to an array at space -&gt; [&quot;30&quot;, &quot;Days&quot;, &quot;Of&quot;, &quot;JavaScript&quot;]let firstName = &#39;Asabeneh&#39;console.log(firstName.split())    // Change to an array - &gt; [&quot;Asabeneh&quot;]console.log(firstName.split(&#39;&#39;))  // Split to an array at each letter -&gt;  [&quot;A&quot;, &quot;s&quot;, &quot;a&quot;, &quot;b&quot;, &quot;e&quot;, &quot;n&quot;, &quot;e&quot;, &quot;h&quot;]let countries = &#39;Finland, Sweden, Norway, Denmark, and Iceland&#39;console.log(countries.split(&#39;,&#39;))  // split to any array at comma -&gt; [&quot;Finland&quot;, &quot; Sweden&quot;, &quot; Norway&quot;, &quot; Denmark&quot;, &quot; and Iceland&quot;]console.log(countries.split(&#39;, &#39;)) //  [&quot;Finland&quot;, &quot;Sweden&quot;, &quot;Norway&quot;, &quot;Denmark&quot;, &quot;and Iceland&quot;]</code></pre><h2 id="trim（）：删除字符串开头或结尾的尾部空格。"><a href="#trim（）：删除字符串开头或结尾的尾部空格。" class="headerlink" title="trim（）：删除字符串开头或结尾的尾部空格。"></a>trim（）：删除字符串开头或结尾的尾部空格。</h2><pre><code>let string = &#39;   30 Days Of JavaScript   &#39;console.log(string)console.log(string.trim(&#39; &#39;))let firstName = &#39; Asabeneh &#39;console.log(firstName)console.log(firstName.trim())  // still removes spaces at the beginning and the end of the string</code></pre><h2 id="include（）：它接受一个子字符串参数，并检查字符串中是否存在子字符串参数。-include（）返回一个布尔值。-如果字符串中存在子字符串，则返回true，否则返回false。"><a href="#include（）：它接受一个子字符串参数，并检查字符串中是否存在子字符串参数。-include（）返回一个布尔值。-如果字符串中存在子字符串，则返回true，否则返回false。" class="headerlink" title="include（）：它接受一个子字符串参数，并检查字符串中是否存在子字符串参数。 include（）返回一个布尔值。 如果字符串中存在子字符串，则返回true，否则返回false。"></a>include（）：它接受一个子字符串参数，并检查字符串中是否存在子字符串参数。 include（）返回一个布尔值。 如果字符串中存在子字符串，则返回true，否则返回false。</h2><pre><code>let string = &#39;30 Days Of JavaScript&#39;console.log(string.includes(&#39;Days&#39;))     // trueconsole.log(string.includes(&#39;days&#39;))     // false - it is case sensitive!console.log(string.includes(&#39;Script&#39;))   // trueconsole.log(string.includes(&#39;script&#39;))   // falseconsole.log(string.includes(&#39;java&#39;))     // falseconsole.log(string.includes(&#39;Java&#39;))     // truelet country = &#39;Finland&#39;console.log(country.includes(&#39;fin&#39;))     // falseconsole.log(country.includes(&#39;Fin&#39;))     // trueconsole.log(country.includes(&#39;land&#39;))    // trueconsole.log(country.includes(&#39;Land&#39;))    // false</code></pre><h2 id="replace（）：将旧的子字符串和新的子字符串作为参数。"><a href="#replace（）：将旧的子字符串和新的子字符串作为参数。" class="headerlink" title="replace（）：将旧的子字符串和新的子字符串作为参数。"></a>replace（）：将旧的子字符串和新的子字符串作为参数。</h2><pre><code>let string = &#39;30 Days Of JavaScript&#39;console.log(string.replace(&#39;JavaScript&#39;, &#39;Python&#39;)) // 30 Days Of Pythonlet country = &#39;Finland&#39;console.log(country.replace(&#39;Fin&#39;, &#39;Noman&#39;))       // Nomanland</code></pre><h2 id="charAt-取index并返回该索引处的值"><a href="#charAt-取index并返回该索引处的值" class="headerlink" title="charAt() 取index并返回该索引处的值"></a>charAt() 取index并返回该索引处的值</h2><pre><code>let string = &#39;30 Days Of JavaScript&#39;console.log(string.charAt(0))        // 3let lastIndex = string.length - 1console.log(string.charAt(lastIndex)) // t</code></pre><h2 id="charCodeAt-取index并返回索引处值的字符代码-ASCII码"><a href="#charCodeAt-取index并返回索引处值的字符代码-ASCII码" class="headerlink" title="charCodeAt(): 取index并返回索引处值的字符代码(ASCII码)"></a>charCodeAt(): 取index并返回索引处值的字符代码(ASCII码)</h2><pre><code>let string = &#39;30 Days Of JavaScript&#39;console.log(string.charCodeAt(3))        // D ASCII number is 68let lastIndex = string.length - 1console.log(string.charCodeAt(lastIndex)) // t ASCII is 116</code></pre><h2 id="indexOf-接受一个子字符串，如果子字符串在字符串中存在，它将返回子字符串的第一个位置，如果不存在则返回-1"><a href="#indexOf-接受一个子字符串，如果子字符串在字符串中存在，它将返回子字符串的第一个位置，如果不存在则返回-1" class="headerlink" title="indexOf(): 接受一个子字符串，如果子字符串在字符串中存在，它将返回子字符串的第一个位置，如果不存在则返回-1"></a>indexOf(): 接受一个子字符串，如果子字符串在字符串中存在，它将返回子字符串的第一个位置，如果不存在则返回-1</h2><pre><code>let string = &#39;30 Days Of JavaScript&#39;console.log(string.indexOf(&#39;D&#39;))          // 3console.log(string.indexOf(&#39;Days&#39;))       // 3console.log(string.indexOf(&#39;days&#39;))       // -1</code></pre><p>lastIndexOf(): 接受一个子字符串，如果子字符串在字符串中存在，则返回子字符串的最后一个位置，如果不存在则返回-1</p><pre><code>let string = &#39;I love JavaScript. If you do not love JavaScript what else can you love.&#39;console.log(string.lastIndexOf(&#39;love&#39;))       // 67console.log(string.lastIndexOf(&#39;you&#39;))        // 63</code></pre><h2 id="concat-它接受许多子字符串并连接它们。"><a href="#concat-它接受许多子字符串并连接它们。" class="headerlink" title="concat(): 它接受许多子字符串并连接它们。"></a>concat(): 它接受许多子字符串并连接它们。</h2><pre><code>string.concat(substring, substring, substring)</code></pre><h2 id="startsWith-它将一个子字符串作为参数，并检查该字符串是否以指定的子字符串开始。它返回一个布尔值-true或false-。"><a href="#startsWith-它将一个子字符串作为参数，并检查该字符串是否以指定的子字符串开始。它返回一个布尔值-true或false-。" class="headerlink" title="startsWith: 它将一个子字符串作为参数，并检查该字符串是否以指定的子字符串开始。它返回一个布尔值(true或false)。"></a>startsWith: 它将一个子字符串作为参数，并检查该字符串是否以指定的子字符串开始。它返回一个布尔值(true或false)。</h2><pre><code>let string = &#39;Love is the best to in this world&#39;console.log(string.startsWith(&#39;Love&#39;))   // true</code></pre><h2 id="endsWith-它将一个子字符串作为参数，并检查该字符串是否以指定的子字符串结束。它返回一个布尔值-true或false-。"><a href="#endsWith-它将一个子字符串作为参数，并检查该字符串是否以指定的子字符串结束。它返回一个布尔值-true或false-。" class="headerlink" title="endsWith: 它将一个子字符串作为参数，并检查该字符串是否以指定的子字符串结束。它返回一个布尔值(true或false)。"></a>endsWith: 它将一个子字符串作为参数，并检查该字符串是否以指定的子字符串结束。它返回一个布尔值(true或false)。</h2><pre><code>let string = &#39;Love is the most powerful feeling in the world&#39;console.log(string.endsWith(&#39;world&#39;))         // true</code></pre><h2 id="search-它接受子字符串作为参数，并返回第一个匹配的索引。搜索值可以是字符串或正则表达式模式。"><a href="#search-它接受子字符串作为参数，并返回第一个匹配的索引。搜索值可以是字符串或正则表达式模式。" class="headerlink" title="search: 它接受子字符串作为参数，并返回第一个匹配的索引。搜索值可以是字符串或正则表达式模式。"></a>search: 它接受子字符串作为参数，并返回第一个匹配的索引。搜索值可以是字符串或正则表达式模式。</h2><pre><code>let string = &#39;I love JavaScript. If you do not love JavaScript what else can you love.&#39;console.log(string.search(&#39;love&#39;))          // 2</code></pre><h2 id="match：将子字符串或正则表达式模式作为参数，如果匹配则返回数组，否则返回null。-让我们看看正则表达式模式的样子。-它以-符号开头，以-符号结尾。"><a href="#match：将子字符串或正则表达式模式作为参数，如果匹配则返回数组，否则返回null。-让我们看看正则表达式模式的样子。-它以-符号开头，以-符号结尾。" class="headerlink" title="match：将子字符串或正则表达式模式作为参数，如果匹配则返回数组，否则返回null。 让我们看看正则表达式模式的样子。 它以/符号开头，以/符号结尾。"></a>match：将子字符串或正则表达式模式作为参数，如果匹配则返回数组，否则返回null。 让我们看看正则表达式模式的样子。 它以/符号开头，以/符号结尾。</h2><pre><code>let string = &#39;I love JavaScript. If you do not love JavaScript what else can you love.&#39;console.log(string.match(&#39;love&#39;))console.log(string.match(/love/gi))   // [&quot;love&quot;, &quot;love&quot;, &quot;love&quot;]</code></pre><h2 id="repeat（）：它以数字作为参数，并返回字符串的重复版本。"><a href="#repeat（）：它以数字作为参数，并返回字符串的重复版本。" class="headerlink" title="repeat（）：它以数字作为参数，并返回字符串的重复版本。"></a>repeat（）：它以数字作为参数，并返回字符串的重复版本。</h2><pre><code>let string = &#39;love&#39;console.log(string.repeat(10)) // lovelovelovelovelovelovelovelovelovelove</code></pre><h1 id="字符串转浮点数"><a href="#字符串转浮点数" class="headerlink" title="字符串转浮点数"></a>字符串转浮点数</h1><p>我们可以将字符串浮点数转换为浮点数。 引号内的任何浮点数都是字符串浮点数。 字符串浮点数的示例：’9.81’，’3.14’，’1.44’等。我们可以使用以下方法将字符串浮点数转换为数字：</p><ol><li>parseFloat()</li><li>Number()</li><li>使用加号(+)</li></ol><pre><code>let num = &#39;9.81&#39;;let numFloat = parseFloat(num);let numFloat2 = Number(num);let numFloat3 = +num;console.log(numFloat); // 9.81</code></pre><h1 id="字符串转整数"><a href="#字符串转整数" class="headerlink" title="字符串转整数"></a>字符串转整数</h1><p>我们可以将浮点数转换为整数。 我们使用以下方法将float转换为int：</p><ol><li>parseInt()</li></ol><pre><code>let num = 9.81let numInt = parseInt(num)console.log(numInt); // 9</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript的30天基础巩固</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript第一天</title>
    <link href="/2021/05/09/JavaScript%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <url>/2021/05/09/JavaScript%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<p>开始学习挑战30天JavaScript的第一天。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>祝贺您决定参加30天的JavaScript编程挑战赛。 在这个挑战中，您将学到成为JavaScript程序员所需的一切，并且通常会学习整个编程概念。 挑战结束时，您将获得30DaysOfJavaScript编程挑战完成证书。 如果您需要帮助或想要帮助他人，可以加入电报组。</p><p>30DaysOfJavaScript挑战是面向初学者和高级JavaScript开发人员的指南。 欢迎使用JavaScript。 JavaScript是网络语言。 我喜欢使用和教授JavaScript，也希望您也能这样做。</p><p>在循序渐进的JavaScript挑战中，您将学习JavaScript，这是人类历史上最流行的编程语言。 JavaScript用于添加网站的交互性，开发移动应用程序，桌面应用程序，游戏，如今，JavaScript可用于机器学习和AI。 近年来，JavaScript（JS）越来越流行，并且已经连续六年成为领先的编程语言，并且是Github上使用最多的编程语言。</p><h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><p>不需要任何编程知识就可以应对这一挑战。 您只需要：</p><ol><li>学习动机</li><li>一台电脑</li><li>互联网</li><li>浏览器</li><li>代码编辑器</li></ol><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>我相信您有成为开发人员，计算机和互联网的动力和强烈愿望。 如果有这些，那么您就有一切开始。</p><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>您现在可能不需要node.js，但以后可能需要它。 安装node.js。<br>下载程序后双击安装<br>我们可以通过打开设备终端或命令提示符来检查是否在本地计算机上安装了节点。</p><pre><code>$ node -vv12.14.0</code></pre><p>在制作本教程时，我使用的是节点版本12.14.0，但是现在建议下载的node.js版本是12.17.0。</p><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><p>有很多浏览器。 但是，我强烈建议您使用Google Chrome浏览器。</p><h2 id="下载-Google-Chrome"><a href="#下载-Google-Chrome" class="headerlink" title="下载 Google Chrome"></a>下载 Google Chrome</h2><p>直接搜索“Google Chrome” 下载安装即可</p><h2 id="打开谷歌浏览器控制台"><a href="#打开谷歌浏览器控制台" class="headerlink" title="打开谷歌浏览器控制台"></a>打开谷歌浏览器控制台</h2><p>您可以通过单击浏览器右上角的三个点，然后选择“更多工具-&gt;开发者工具”或使用键盘快捷键来打开Goog​​le Chrome控制台。 我更喜欢使用快捷方式。<br>使用键盘快捷键打开Chrome控制台。</p><pre><code>MacCommand+Option+JWindows/Linux:Ctl+Shift+J</code></pre><p>打开Goog​​le Chrome控制台后，尝试浏览标记的按钮。 我们将大部分时间花在控制台上。 控制台是您的JavaScript代码所在的地方。 Google Console V8引擎将您的JavaScript代码更改为机器代码。 让我们在Google Chrome控制台上编写JavaScript代码.</p><h2 id="在浏览器控制台编写代码"><a href="#在浏览器控制台编写代码" class="headerlink" title="在浏览器控制台编写代码"></a>在浏览器控制台编写代码</h2><p>我们可以在Google控制台或任何浏览器控制台上编写任何JavaScript代码。 但是，对于这一挑战，我们仅关注Google Chrome控制台。 使用以下命令打开控制台：</p><pre><code>MacCommand+Option+IWindows:Ctl+Shift+I</code></pre><h2 id="console-log"><a href="#console-log" class="headerlink" title="console.log"></a>console.log</h2><p>为了编写第一个JavaScript代码，我们使用了内置函数console.log（）。 我们传递了一个参数作为输入数据，该函数显示了输出。 我们在console.log（）函数中传递了“ Hello，World”作为输入数据或参数。</p><pre><code>console.log(&quot;Hello World!&quot;);</code></pre><h2 id="console-log-带有多个参数的日志"><a href="#console-log-带有多个参数的日志" class="headerlink" title="console.log 带有多个参数的日志"></a>console.log 带有多个参数的日志</h2><p>conole.log()函数可以采用多个参数，并用逗号分隔。 语法如下所示：console.log(param1，param2，param3)</p><pre><code>console.log(&#39;Hello&#39;, &#39;World&#39;, &#39;!&#39;)console.log(&#39;HAPPY&#39;, &#39;NEW&#39;, &#39;YEAR&#39;, 2020)console.log(&#39;Welcome&#39;, &#39;to&#39;, 30, &#39;Days&#39;, &#39;Of&#39;, &#39;JavaScript&#39;)</code></pre><p>您可以从上面的代码段看到，console.log()可以使用多个参数。<br>恭喜你！ 您使用console.log()编写了第一个JavaScript代码。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>我们在代码中添加注释。 注释对于使代码更具可读性并在我们的代码中留下备注非常重要。 JavaScript不会执行代码的注释部分。在JavaScript中，以//开头的任何文本行都是注释，而像/ * * /这样的内容也是注释。<br>示例：单行注释</p><pre><code>// This is the first comment// This is the second comment// I am a single line comment</code></pre><p>示例：多行注释</p><pre><code>/* This is a multiline commentMultiline comments can take multiple linesJavaScript is the language of the web*/</code></pre><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>编程语言与人类语言相似。 英语或许多其他语言使用单词，短语，句子，复合句子及其他内容来传达有意义的信息。 语法的英语含义是单词和短语的排列，以创建一种语言形式良好的句子。 语法的技术定义是计算机语言中语句的结构。 编程语言具有语法。 JavaScript是一种编程语言，并且像其他编程语言一样，它具有自己的语法。 如果我们没有编写JavaScript可以理解的语法，它将引发不同类型的错误。 稍后，我们将探讨各种JavaScript错误。 现在，让我们看看语法错误</p><h2 id="算数"><a href="#算数" class="headerlink" title="算数"></a>算数</h2><p>现在，让我们练习更多使用google chrome控制台上的console.log（）编写数字数据类型的JavaScript代码的方法。 除了文本之外，我们还可以使用JavaScript进行数学计算。 让我们做以下简单的计算。 控制台可以直接使用参数，而无需console.log（）函数。 但是，它包含在本简介中，因为大多数挑战将在文本编辑器中进行，在该文本编辑器中必须强制使用该功能。 您可以直接按照控制台上的说明进行操作。</p><pre><code>console.log(2 + 3) // Additionconsole.log(3 - 2) // Subtractionconsole.log(2 * 3) // Multiplicationconsole.log(3 / 2) // Divisionconsole.log(3 % 2) // Modulus - finding remainderconsole.log(3 ** 2) // Exponentiation 3 ** 2 == 3 * 3</code></pre><h1 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h1><p>我们可以在浏览器控制台上编写代码，但不适用于较大的项目。 在实际的工作环境中，开发人员使用不同的代码编辑器来编写他们的代码。 在这30天的JavaScript挑战中，我们将使用Visual Studio Code。搜索下载安装即可</p><h1 id="数据类型介绍"><a href="#数据类型介绍" class="headerlink" title="数据类型介绍"></a>数据类型介绍</h1><p>在JavaScript和其他编程语言中，存在不同类型的数据类型。 以下是JavaScript基本数据类型：String(字符串)，Number(数字)，Boolean(布尔值)，Undefined(未定义)，Null(空值)和Symbol(符号)。</p><h2 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h2><p>Integers: 整数（负数，零和正数）示例：… -3，-2，-1、0、1、2、3 …<br>浮点数：十进制数示例:… -3.5，-2.25，-1.0，0.0，1.1，2.2，3.5 …</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>两个单引号，双引号或反引号之间的一个或多个字符的集合。 例子：</p><pre><code>&#39;Asabeneh&#39;&#39;Finland&#39;&#39;JavaScript is a beautiful programming language&#39;&#39;I love teaching&#39;&#39;I hope you are enjoying the first day&#39;`We can also create a string using a backtick`;(&#39;A string could be just as small as one character as big as many pages&#39;)</code></pre><h2 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h2><p>布尔值是True或False。 任何比较都会返回一个布尔值，该布尔值可以为true或false。</p><h2 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h2><p>在JavaScript中，如果我们不给变量赋值，则该值是不确定的。 除此之外，如果函数不返回任何内容，则返回undefined。</p><h2 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h2><p>JavaScript中的Null表示一个空值。</p><h2 id="查看各个值的数据类型"><a href="#查看各个值的数据类型" class="headerlink" title="查看各个值的数据类型"></a>查看各个值的数据类型</h2><p>要检查某个变量的数据类型，我们使用typeof运算符。 请参见以下示例。</p><pre><code>console.log(typeof &#39;Asabeneh&#39;) // stringconsole.log(typeof 5) // numberconsole.log(typeof true) // booleanconsole.log(typeof null) // object typeconsole.log(typeof undefined) // undefined</code></pre><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量是数据的容器。 变量用于将数据存储在存储位置中。 声明变量后，将保留一个存储位置。 将变量分配给值（数据）后，存储空间将被该数据填充。 要声明变量，我们使用var，let或const关键字。</p><p>对于在不同时间更改的变量，我们使用let。 如果数据完全不变，则使用const。 例如，PI，国家名称，重力不变，我们可以使用const。 我们不会在此挑战中使用var，我不建议您使用它。 声明变量有很多泄漏是易于出错的方式。 我们将在其他部分（范围）中详细讨论var，let和const。 就目前而言，上面的解释就足够了。</p><p>有效的JavaScript变量名称必须遵循以下规则：</p><ol><li>JavaScript变量名称不应以数字开头。</li><li>JavaScript变量名称不允许使用特殊字符，但美元符号和下划线除外。</li><li>JavaScript变量名称遵循camelCase约定。</li><li>JavaScript变量名称的单词之间不应有空格。</li></ol><h2 id="声明的变量的例子"><a href="#声明的变量的例子" class="headerlink" title="声明的变量的例子"></a>声明的变量的例子</h2><pre><code>let firstName = &#39;Asabeneh&#39; // first name of a personlet lastName = &#39;Yetayeh&#39; // last name of a personlet country = &#39;Finland&#39; // countrylet city = &#39;Helsinki&#39; // capital citylet age = 100 // age in yearslet isMarried = trueconsole.log(firstName, lastName, country, city, age, isMarried)const gravity = 9.81 // earth gravity  in m/s2const boilingPoint = 100 // water boiling point, temperature in oCconst PI = 3.14 // geometrical constantconsole.log(gravity, boilingPoint, PI);let name = &#39;Asabeneh&#39;, // name of a person  job = &#39;teacher&#39;,  live = &#39;Finland&#39;console.log(name, job, live)</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript的30天基础巩固</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>setState到底是同步还是异步的</title>
    <link href="/2021/04/01/setState%E5%88%B0%E5%BA%95%E6%98%AF%E5%90%8C%E6%AD%A5%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84/"/>
    <url>/2021/04/01/setState%E5%88%B0%E5%BA%95%E6%98%AF%E5%90%8C%E6%AD%A5%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p><img src="http://img.kuagra.top/wallhaven-3zlo9d_1920x1080.png" srcset="/img/loading.gif" alt=""></p><h1 id="setState到底是同步还是异步的呢？"><a href="#setState到底是同步还是异步的呢？" class="headerlink" title="setState到底是同步还是异步的呢？"></a>setState到底是同步还是异步的呢？</h1><p>setState在React管控下始终是异步的，在逃离React管控下时是同步的。如何理解呢，下面让我们走进react的更新机制去寻找一下。</p><h2 id="React的更新机制，异步的动机和原理，批量更新的艺术"><a href="#React的更新机制，异步的动机和原理，批量更新的艺术" class="headerlink" title="React的更新机制，异步的动机和原理，批量更新的艺术"></a>React的更新机制，异步的动机和原理，批量更新的艺术</h2><p>我们先来了解一下setState会触发到那些生命周期，如下所示：</p><pre><code>setState =&gt; shouldComponentUpdate =&gt; componentWillUpdate =&gt; render =&gt; componentDidUpdate</code></pre><p>试想一下，如果我们同时调用多个setState，每次setState都执行上面的流程的话，页面将会卡死；这也是React设置异步更新的动机–避免频繁的re-render。<br>setState的异步实现方式有点类似于Event-Loop: 每来一个setState，就把它放进一个队列里面，等待时机成熟，在把队列里面的state做一次合并，最后只针对最新的state值做一次更新流程，这个过程叫做“批量更新”。</p><h2 id="“同步现象”现象背后的故事：-从源码角度看setState工作流"><a href="#“同步现象”现象背后的故事：-从源码角度看setState工作流" class="headerlink" title="“同步现象”现象背后的故事： 从源码角度看setState工作流"></a>“同步现象”现象背后的故事： 从源码角度看setState工作流</h2><p>同步现象：当我们在setTimeout的保护之下，setState出现了同步现象。<br>为什么setTimeout可以将setState的执行顺序从异步变成同步的呢？<br>先给我一个结论：并不是setTimeout改变了setState，而是setTimeout帮助setState逃离了react对它的管控。只要是react管控下setState一定是异步的。<br>通过这个结论，我们去源码中寻找答案。</p><h3 id="解读setState的工作流"><a href="#解读setState的工作流" class="headerlink" title="解读setState的工作流"></a>解读setState的工作流</h3><p>setState的主工作流大致如下所示：</p><pre><code>                    setState                        |                    enqueueSetState                        |                    enqueueUpState                        |                    isBatchingUpdates                        |    ----true-----------------------------false-------    |                                               |组件入队                                        循环更新dirtyComponents                                dirtyComponents里面的所有组件</code></pre><h3 id="通过源码深入理解setState工作流"><a href="#通过源码深入理解setState工作流" class="headerlink" title="通过源码深入理解setState工作流"></a>通过源码深入理解setState工作流</h3><p>通过上面的流程，我们到源码中去看,首先是setState入口函数</p><pre><code class="javascript">ReactComponent.prototype.setState = function (partialState, callback) {    this.updater.enqueueSetState(this, partialState);    if (callback) {        this.updater.enqueueCallback(this, callback, &#39;setState&#39;);    }};</code></pre><p>入口函数在这里就是充当一个分发器的角色，根据入参的不同，将其分发到不同的功能函数中去。<br>在来看看enqueueSetState做了什么</p><pre><code class="javascript">enqueueSetState: function (publicInstance, partialState) {  // 根据 this 拿到对应的组件实例  var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, &#39;setState&#39;);  // 这个 queue 对应的就是一个组件实例的 state 数组  var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);  queue.push(partialState);  //  enqueueUpdate 用来处理当前的组件实例  enqueueUpdate(internalInstance);}</code></pre><p>enqueueSetState大致做了两件事：</p><ul><li>将新的state放入组件状态队列里</li><li>用enqueueUpdate来处理将要更新的实例对象</li></ul><p>我们在去enqueueUpdate里面看看做什么事情</p><pre><code class="javascript">function enqueueUpdate(component) {  ensureInjected();  // 注意这一句是问题的关键，isBatchingUpdates标识着当前是否处于批量创建/更新组件的阶段  if (!batchingStrategy.isBatchingUpdates) {    // 若当前没有处于批量创建/更新组件的阶段，则立即更新组件    batchingStrategy.batchedUpdates(enqueueUpdate, component);    return;  }  // 否则，先把组件塞入 dirtyComponents 队列里，让它“再等等”  dirtyComponents.push(component);  if (component._updateBatchNumber == null) {    component._updateBatchNumber = updateBatchNumber + 1;  }}</code></pre><p>通过源码，我们看到enqueueUpdate中引入了一个关键对象—batchingStrategy。<br>该对象具备isBatchingUpdates属性，直接决定了当下要走的更新流程，还是排队等待。其中的batchedUpdates 方法更是能够直接发起更新流程。<br>由此我们可以看出：batchingStrategy 或许正是 React 内部专门用于管控批量更新的对象。</p><p>下面我们去看看batchingStrategy这个关键的对象</p><pre><code class="javascript">/** * batchingStrategy源码**/var ReactDefaultBatchingStrategy = {  // 全局唯一的锁标识  isBatchingUpdates: false,  // 发起更新动作的方法  batchedUpdates: function(callback, a, b, c, d, e) {    // 缓存锁变量    var alreadyBatchingStrategy = ReactDefaultBatchingStrategy.isBatchingUpdates;    // 把锁“锁上”    ReactDefaultBatchingStrategy.isBatchingUpdates = true;    if (alreadyBatchingStrategy) {      callback(a, b, c, d, e);    } else {      // 启动事务，将 callback 放进事务里执行      transaction.perform(callback, null, a, b, c, d, e);    }  }}</code></pre><p>batchingStrategy 对象并不复杂，你可以理解为它是一个“锁管理器”。</p><p>这里的“锁”，是指 React 全局唯一的 isBatchingUpdates 变量，isBatchingUpdates 的初始值是 false，意味着“当前并未进行任何批量更新操作”。每当 React 调用 batchedUpdate 去执行更新动作时，会先把这个锁给“锁上”（置为 true），表明“现在正处于批量更新过程中”。当锁被“锁上”的时候，任何需要更新的组件都只能暂时进入 dirtyComponents 里排队等候下一次的批量更新，而不能随意“插队”。此处体现的“任务锁”的思想，是 React 面对大量状态仍然能够实现有序分批处理的基石。</p><p>在batchingStrategy中引入了一个硬核的东西</p><pre><code class="javascript">    transaction.perform(callback, null, a, b, c, d, e);</code></pre><p>这行代码为我们引出了一个更为硬核的概念——React 中的 Transaction（事务）机制。</p><h2 id="理解-React-中的-Transaction（事务）-机制"><a href="#理解-React-中的-Transaction（事务）-机制" class="headerlink" title="理解 React 中的 Transaction（事务） 机制"></a>理解 React 中的 Transaction（事务） 机制</h2><p>Transaction 在 React 源码中的分布可以说非常广泛。如果你在 Debug React 项目的过程中，发现函数调用栈中出现了 initialize、perform、close、closeAll 或者 notifyAll 这样的方法名，那么很可能你当前就处于一个 Trasaction 中。<br>Transaction 在 React 源码中表现为一个核心类，React 官方曾经这样描述它：<strong>Transaction 是创建一个黑盒，该黑盒能够封装任何的方法。</strong>因此，那些需要在函数运行前、后运行的方法可以通过此方法封装（即使函数运行中有异常抛出，这些固定的方法仍可运行），实例化 Transaction 时只需提供相关的方法即可。<br>下面是源码中的一段针对 Transaction 的注释：</p><pre><code class="javascript">* &lt;pre&gt; *                       wrappers (injected at creation time) *                                      +        + *                                      |        | *                    +-----------------|--------|--------------+ *                    |                 v        |              | *                    |      +---------------+   |              | *                    |   +--|    wrapper1   |---|----+         | *                    |   |  +---------------+   v    |         | *                    |   |          +-------------+  |         | *                    |   |     +----|   wrapper2  |--------+   | *                    |   |     |    +-------------+  |     |   | *                    |   |     |                     |     |   | *                    |   v     v                     v     v   | wrapper *                    | +---+ +---+   +---------+   +---+ +---+ | invariants * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained * +-----------------&gt;|-|---|-|---|--&gt;|anyMethod|---|---|-|---|-|--------&gt; *                    | |   | |   |   |         |   |   | |   | | *                    | |   | |   |   |         |   |   | |   | | *                    | |   | |   |   |         |   |   | |   | | *                    | +---+ +---+   +---------+   +---+ +---+ | *                    |  initialize                    close    | *                    +-----------------------------------------+ * &lt;/pre&gt;</code></pre><p>说白了，Transaction 就像是一个“壳子”，它首先会将目标函数用 wrapper（一组 initialize 及 close 方法称为一个 wrapper） 封装起来，同时需要使用 Transaction 类暴露的 perform 方法去执行它。如上面的注释所示，在 anyMethod 执行之前，perform 会先执行所有 wrapper 的 initialize 方法，执行完后，再执行所有 wrapper 的 close 方法。这就是 React 中的事务机制。</p><h2 id="“同步现象”的本质"><a href="#“同步现象”的本质" class="headerlink" title="“同步现象”的本质"></a>“同步现象”的本质</h2><p>通过对事务的理解，ReactDefaultBatchingStrategy 其实就是一个批量更新策略事务，它的 wrapper 有两个：FLUSH_BATCHED_UPDATES 和 RESET_BATCHED_UPDATES。</p><pre><code class="javascript">var RESET_BATCHED_UPDATES = {  initialize: emptyFunction,  close: function () {    ReactDefaultBatchingStrategy.isBatchingUpdates = false;  }};var FLUSH_BATCHED_UPDATES = {  initialize: emptyFunction,  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)};var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];</code></pre><p>我们将这两个wrapper套入上面注释中去，不难得出这样的流程：<br>在callback执行完成后RESET_BATCHED_UPDATES将isBatchingUpdates修改为false，FLUSH_BATCHED_UPDATES执行flushBatchedUpdates，然后里面会循环所有的dirtyComponents,调用updateComponent来执行所有的生命周期方法。componentWillReceiveProps &gt; shouldComponentUpdate &gt; componentWillUpdate &gt; componentDidUpdate。 最后实现组件的更新。</p><p>其实batchingUpdates在很多地方都有调用，例如在首次渲染的时候：</p><pre><code class="javascript">// ReactMount.js_renderNewRootComponent: function( nextElement, container, shouldReuseMarkup, context ) {  // 实例化组件  var componentInstance = instantiateReactComponent(nextElement);  // 初始渲染直接调用 batchedUpdates 进行同步渲染  ReactUpdates.batchedUpdates(    batchedMountComponentIntoNode,    componentInstance,    container,    shouldReuseMarkup,    context  );  ...}</code></pre><p>这段代码是在首次渲染组件时会执行的一个方法，我们看到它内部调用了一次 batchedUpdates，这是因为在组件的渲染过程中，会按照顺序调用各个生命周期函数。开发者很有可能在声明周期函数中调用 setState。因此，我们需要通过开启 batch 来确保所有的更新都能够进入 dirtyComponents 里去，进而确保初始渲染流程中所有的 setState 都是生效的。</p><p>下面代码是 React 事件系统的一部分。当我们在组件上绑定了事件之后，事件中也有可能会触发 setState。为了确保每一次 setState 都有效，React 同样会在此处手动开启批量更新。</p><pre><code class="javascript">// ReactEventListener.jsdispatchEvent: function (topLevelType, nativeEvent) {  ...  try {    // 处理事件    ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);  } finally {    TopLevelCallbackBookKeeping.release(bookKeeping);  }}</code></pre><p>可以看出isBatchingUpdates 这个变量，在 React 的生命周期函数以及合成事件执行前，已经被 React 悄悄修改为了 true，这时我们所做的 setState 操作自然不会立即生效。当函数执行完毕后，事务的 close 方法会再把 isBatchingUpdates 改为 false。</p><p>我们都是知道setTimeout是异步执行的，它内部是完全没有约束的，而isBatchingUpdates又是在同步的修改，当setTimeout中的setState执行时，isBatchingUpdates早就被修改为了false。也就是我们之前说的逃离了react的管控，也就出现了同步更新的现象。<br><strong style="color:red;">setState 并不是具备同步这种特性，只是在特定的情境下，它会从 React 的异步管控中“逃脱”掉。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>深入理解react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React虚拟Dom的理解</title>
    <link href="/2021/03/23/React%E8%99%9A%E6%8B%9FDom%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2021/03/23/React%E8%99%9A%E6%8B%9FDom%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><img src="http://img.kuagra.top/wallhaven-y8x95d_1920x1080.png" srcset="/img/loading.gif" alt=""></p><h1 id="React虚拟Dom的理解"><a href="#React虚拟Dom的理解" class="headerlink" title="React虚拟Dom的理解"></a>React虚拟Dom的理解</h1><h2 id="什么是React虚拟Dom"><a href="#什么是React虚拟Dom" class="headerlink" title="什么是React虚拟Dom"></a>什么是React虚拟Dom</h2><p>虚拟Dom是对真实Dom的一种映射，也就是虚拟Dom是真实Dom的另一种表现形式。<br>react虚拟Dom是js对象，react虚拟Dom是对真实Dom的一种描述，本质上是JS和Dom之间的一个映射缓存。</p><h2 id="React生成虚拟Dom到界面的大致过程"><a href="#React生成虚拟Dom到界面的大致过程" class="headerlink" title="React生成虚拟Dom到界面的大致过程"></a>React生成虚拟Dom到界面的大致过程</h2><p>在挂载阶段：React将结合jsx描述构建出虚拟Dom树，然后通过ReactDom.render实现虚拟Dom树到真实Dom树的映射，触发渲染流程。<br>在更新阶段：页面的变化在作用于真实Dom之前会先作用于虚拟Dom，虚拟Dom将在js层借助算法先对比出具体有那些真实Dom需要被改变，然后在将这些改变作用于真实Dom。</p><h2 id="React选用虚拟Dom真的是解决性能吗"><a href="#React选用虚拟Dom真的是解决性能吗" class="headerlink" title="React选用虚拟Dom真的是解决性能吗"></a>React选用虚拟Dom真的是解决性能吗</h2><p>我觉得性能问题不能一概而论，性能问题决定的因素很多。<br>虚拟Dom真正的作用在于提高了(开发体验/开发效率)，虚拟Dom能为我们做更多的事情。jsx形式的语法糖很适用前端的开发人，它和HTML语法很相似，但又完全不同。jsx也就是我们对虚拟Dom的另一种表达方式。<br>使用虚拟Dom我们可以实现一次编译多端运行；例如我们可以通过虚拟Dom编译生成网页，小程序，IOS应用，Android应用等。大大的提高了我们开发效率，满足了丰富的应用交互效果。</p>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>深入理解react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端查看已安装的依赖包</title>
    <link href="/2021/03/22/%E5%89%8D%E7%AB%AF%E6%9F%A5%E7%9C%8B%E5%B7%B2%E5%AE%89%E8%A3%85%E7%9A%84%E4%BE%9D%E8%B5%96%E5%8C%85/"/>
    <url>/2021/03/22/%E5%89%8D%E7%AB%AF%E6%9F%A5%E7%9C%8B%E5%B7%B2%E5%AE%89%E8%A3%85%E7%9A%84%E4%BE%9D%E8%B5%96%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="使用yarn查看已安装的依赖包"><a href="#使用yarn查看已安装的依赖包" class="headerlink" title="使用yarn查看已安装的依赖包"></a>使用yarn查看已安装的依赖包</h1><h2 id="查看当前目录下已安装的依赖包"><a href="#查看当前目录下已安装的依赖包" class="headerlink" title="查看当前目录下已安装的依赖包"></a>查看当前目录下已安装的依赖包</h2><pre><code class="javascript">npm list --depth 0 yarn list --depth=0</code></pre><h2 id="全局下已安装的依赖包"><a href="#全局下已安装的依赖包" class="headerlink" title="全局下已安装的依赖包"></a>全局下已安装的依赖包</h2><pre><code class="javascript">npm list -g --depth 0 yarn global list --depth=0</code></pre><p>对于不常用的命令还是想要记录一下。</p>]]></content>
    
    
    
    <tags>
      
      <tag>工作记录</tag>
      
      <tag>yarn使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端二进制流文件的下载</title>
    <link href="/2021/03/22/%E5%89%8D%E7%AB%AF%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%81%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8B%E8%BD%BD/"/>
    <url>/2021/03/22/%E5%89%8D%E7%AB%AF%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%81%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="前端二进制流文件的下载"><a href="#前端二进制流文件的下载" class="headerlink" title="前端二进制流文件的下载"></a>前端二进制流文件的下载</h1><p>前端下载文件一般是通过链接URI直接定位到具体的资源文件上。<br>但有时，这种方式是有局限性，链接的形式方式，也就是说这个文件是公开的，任何人都是可以访问并下载，一般来说后端会对下载的地址设置有效时间。<br>下面这种方式可以很好的实现流文件的下载，但是是确定具体的文件格式或通过其他方式能确定格式的情况下。</p><pre><code class="javascript">const disposition = res.headers[&#39;content-disposition&#39;];// fileName 中应包含文件格式let fileName = disposition.substring(    disposition.indexOf(&#39;filename=&#39;) + 9,    disposition.length,);// iso8859-1的字符转换成中文fileName = decodeURI(escape(fileName));// 文件流转换为Blob对象const blob = new Blob([res.data], { type: &#39;application/octet-stream;&#39; });// 创建下载链接const objectUrl = window.URL.createObjectURL(blob);const link = document.createElement(&#39;a&#39;);link.href = objectUrl;link.download = fileName;// link.click();// 下面这个写法兼容火狐link.dispatchEvent(    new MouseEvent(&#39;click&#39;, { bubbles: true, cancelable: true, view: window }),);// 释放掉objectUrl对象window.URL.revokeObjectURL(objectUrl);</code></pre><p>这种方式如果文件过大，可能会出现内存溢出的问题。<br>它是直接将流存在内存中，最后转成objectUrl形式进行下载，太大的文件无法适用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>工作记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英语学习规划</title>
    <link href="/2020/12/30/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/"/>
    <url>/2020/12/30/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>随着我的自考即将结束，但我又想拿到学位证，故给自己制定了如下的规划。<br>希望自己能坚持下来，当然这也是我的挑战。</p><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>1、每天早上花10分钟记单词（50个），越早越好，但是我可能起不来。（脑子里记到就过，不能纠结，配合使用墨墨背单词）<br>2、每周六找一视频学习语法，尽量提前找好，（时间控制在一小时，专注一小时，暂定b站四级水平查找）<br>3、每周天做一套试卷，（时间控制在两小时，半小时回顾错题，直接到统考网模拟考试）</p><p>任务不可安排太多，学习是加深印象的过程，坚持最重要。</p><h2 id="说说我的坏毛病吧"><a href="#说说我的坏毛病吧" class="headerlink" title="说说我的坏毛病吧"></a>说说我的坏毛病吧</h2><p>1、每天在家上厕所能待一小时，玩手机。<br>2、同样是玩手机，我能在客厅玩很久。<br>3、脑子里有股惰性，喜欢逃避学习。</p><h2 id="如何改变"><a href="#如何改变" class="headerlink" title="如何改变"></a>如何改变</h2><p>1、给自己安排上日程，由时间提醒这我走，很多时候是自己忘记了接下来要干嘛。<br>2、将手机上所有的推送关掉，很多时候我只是想看一下微信，结果很容易引导到其他软件上。<br>3、给自己设定一个休息时间，不然会觉得生活很无趣。<br>4、干掉惰性，设置座右铭时刻提醒自己，<br>一些不是很重要但是又必须要做的重复性事情要尽量想办法用其他的方式替代，给自己争取更多的时间。</p><p>目前就安排这些，看自己能否坚持下来，后续有变动在更新</p>]]></content>
    
    
    
    <tags>
      
      <tag>英语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次bug记录</title>
    <link href="/2020/12/26/%E4%B8%80%E6%AC%A1bug%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/12/26/%E4%B8%80%E6%AC%A1bug%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>今天周六，天气一般（阴）。<br>刚开始不知道写啥，突然想起上周工作时遇到的一个bug，觉得有点意思，想记录一下。<br>事情是这样的。<br>那天我还在悠闲的看着代码，然后啪，测试给我同事来了个bug，然后在他分析后找到我，说是我的bug。<br>看了现象确实是我写的模块，但总觉得是后面出现的问题，深信不疑的我开始看代码分析。<br>最终发现了问题所在，并顺利解决了问题。</p><p>问题是这样出现的</p><p>我写了一个类似于这样的组件</p><pre><code class="javascript">const EditInfo = (props) =&gt; {    /*...*/    const cancel = React.useCallback(()=&gt;{        /*...*/        props.cancel();    },[]);    return &lt;div&gt;        &lt;Button            onClick={cancel}        &gt;点击&lt;/Button&gt;    &lt;/div&gt;}</code></pre><p>然后组件在其他地方是这样使用的</p><pre><code class="javascript">const [selectedKey,setSelectedKey] = useState();// 设置selectKeyconst changeKey = (key) =&gt; {    // 重新设置key    setSelectedKey(key);}&lt;EditInfo    cancel={()=&gt;{        /*这里从上下环境取一值为selectedKey*/        changeKey(selectedKey);    }}/&gt;</code></pre><p>就是这样在我的组件里面第一次编辑成功后没有任何问题，<br>在第二次编辑的时候在次改变selectedKey的值时，此时的值为上一次的值，<br>就是这样出现的很神奇。</p><p>为什么会出现这样呢？</p><p>在页面组件分析完后并没有什么问题，我开始怀疑是我组件的问题，<br>这个时候我开始查看组件代码，最开始就定位点击后发生了什么，我一眼就发现了不对劲的地方。</p><pre><code class="javascript">const cancel = React.useCallback(() =&gt; {        /*...*/        props.cancel();    },[]);</code></pre><p>这里函数写的有问题，如果外部改变了传入的cancel方法，那这里执行的还是之前传入的cancel方法。<br>那么在之前的cancel方法中获取的是之前的selectedKey，也就是为啥每次点击后取到的值都是最开始传入的值。</p><p>解决办法，将组件中的cancel方法进行如下重写</p><pre><code class="javascript">const cancel = React.useCallback(() =&gt; {    /*...*/    props.cancel();},[props.cancel]);</code></pre><p>总结:<br>解决后，我陷入了反思，当时为啥没有把这个加上，按正常的开发是必须要加上的。<br>可能当时并没有真正掌握ReactHook的魔法吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>工作记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英语学习收藏</title>
    <link href="/2020/12/15/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%94%B6%E8%97%8F/"/>
    <url>/2020/12/15/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%94%B6%E8%97%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="最近收藏英语学习相关"><a href="#最近收藏英语学习相关" class="headerlink" title="最近收藏英语学习相关"></a>最近收藏英语学习相关</h2><p>我将持续更新最新的学习方法</p><h3 id="知乎"><a href="#知乎" class="headerlink" title="知乎"></a>知乎</h3><p><a href="https://www.zhihu.com/question/20896608" target="_blank" rel="noopener">https://www.zhihu.com/question/20896608</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>英语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日见闻-20200919</title>
    <link href="/2020/09/19/2020-9-19/"/>
    <url>/2020/09/19/2020-9-19/</url>
    
    <content type="html"><![CDATA[<p><img src="http://img.kuagra.top/pizza-20200919.jpg" srcset="/img/loading.gif" alt="alt 披萨"></p><h1 id="今日见闻"><a href="#今日见闻" class="headerlink" title="今日见闻"></a>今日见闻</h1><h2 id="呆在必胜客的时光"><a href="#呆在必胜客的时光" class="headerlink" title="呆在必胜客的时光"></a>呆在必胜客的时光</h2><p>女朋友今天上班，想着不如就在附近找家店呆一会，于是我看中了必胜客。为啥？ 因为可以上网，还有充电的地方，哈哈哈😂。虽然今天呆在必胜客没有任何的花费，但确让我有了很多的思考。我才能有时间静下来写写博文。<br>下午吃过饭来到了这里，选择了一个空旷的位置，没过一会这里的经理过来和我说一会有人要在这里上课叫我换一个位置。终于坐下了，发现真的有一个外教在这里教课，也就是为啥我来的时候发现大部分就餐的人都是带着小孩的，吃完饭就可以去听课，我也静静的听了一会，发现挺有意思的，教的都是小朋友可以接受的词汇，日常词汇。这个外教应该也是背后外国语学校的老师吧。刚开始还觉得小孩还这么小学习英文能行吗？或许还真行。在我看到大部分小朋友都能说出许多得词汇，虽然发音不标准。<br>我忽略了大部分家长对与孩子教育的渴望，为了让孩子接受到好的教育尽可能的会选择一些好的（贵族）私立学校，这样的学校很多，而我现在遇到的这所学校听说是可以保送到国外读书的。这种对于大部分家长来说绝对有很大的吸引力。<br>好吧，大部分人都在努力着，我也没有理由太沮丧，都不容易啊。</p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工作中常见的git命令</title>
    <link href="/2020/09/19/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84git%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/09/19/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84git%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>最近由于工作的原因对git命令有了新的认识，今天想全部总结一下，也算是做个笔记，后期有新的见解又继续添加。<br>终于又更新了一部分了，希望这些对自己有用。</p><h1 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h1><h2 id="拉取项目"><a href="#拉取项目" class="headerlink" title="拉取项目"></a>拉取项目</h2><pre><code class="git">    git clone [url,ssh]</code></pre><h2 id="git-init-初始化一个仓库"><a href="#git-init-初始化一个仓库" class="headerlink" title="git init 初始化一个仓库"></a>git init 初始化一个仓库</h2><pre><code class="git">$ mkdir git-tutorial$ cd git-tutorial$ git initInitialized empty Git repository in /Users/hirocaster/github/github-book/git-tutorial/.git/</code></pre><h2 id="git-add-向暂存区添加文件"><a href="#git-add-向暂存区添加文件" class="headerlink" title="git add 向暂存区添加文件"></a>git add 向暂存区添加文件</h2><pre><code class="git">    git add README.md</code></pre><h2 id="提交暂存区到本地仓库区"><a href="#提交暂存区到本地仓库区" class="headerlink" title="提交暂存区到本地仓库区"></a>提交暂存区到本地仓库区</h2><pre><code class="git">    git commit -m [message]    // 如果需要详细的描述可不加 -m ，之后弹出编辑框编辑后保存提交</code></pre><h2 id="git-log-查看提交的日志信息"><a href="#git-log-查看提交的日志信息" class="headerlink" title="git log 查看提交的日志信息"></a>git log 查看提交的日志信息</h2><pre><code class="git">    git log    // 想要只显示提交的描述，在log后加上 --pretty=short    // 想要查看提交的文件改动为： git log -p 默认为查看所有改动    // 查看指定文件改动日志：git log -p README.md</code></pre><h2 id="git-diff-查看更改前后的差别"><a href="#git-diff-查看更改前后的差别" class="headerlink" title="git diff 查看更改前后的差别"></a>git diff 查看更改前后的差别</h2><pre><code class="git">    git diff 默认查看当前树和(暂存区,最新提交状态)的差别    git diff HEAD 查看当前提交于上次提交的差别</code></pre><h2 id="查看修改文件状态"><a href="#查看修改文件状态" class="headerlink" title="查看修改文件状态"></a>查看修改文件状态</h2><pre><code class="git">    git status</code></pre><h2 id="查看所有分支"><a href="#查看所有分支" class="headerlink" title="查看所有分支"></a>查看所有分支</h2><pre><code class="git">    git branch -a</code></pre><h2 id="创建一个新分支并切换到改该分支"><a href="#创建一个新分支并切换到改该分支" class="headerlink" title="创建一个新分支并切换到改该分支"></a>创建一个新分支并切换到改该分支</h2><pre><code class="git">    git checkout -b [branch name]</code></pre><h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><pre><code class="git">    git checkout [branch name]</code></pre><h2 id="拉取远程仓库代码并与本地分支合并"><a href="#拉取远程仓库代码并与本地分支合并" class="headerlink" title="拉取远程仓库代码并与本地分支合并"></a>拉取远程仓库代码并与本地分支合并</h2><pre><code class="git">    git pull [remote] [branch]</code></pre><h2 id="上传本地指定分支到远程仓库"><a href="#上传本地指定分支到远程仓库" class="headerlink" title="上传本地指定分支到远程仓库"></a>上传本地指定分支到远程仓库</h2><pre><code class="git">    git push [remote] [branch]</code></pre><h2 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h2><pre><code class="git">    git branch -d [branch name]</code></pre><h2 id="删除远程仓库分支-分支名前的冒号表示删除"><a href="#删除远程仓库分支-分支名前的冒号表示删除" class="headerlink" title="删除远程仓库分支(分支名前的冒号表示删除)"></a>删除远程仓库分支(分支名前的冒号表示删除)</h2><pre><code class="git">    git push origin :branchName </code></pre><h2 id="查看本地已添加的远程仓库"><a href="#查看本地已添加的远程仓库" class="headerlink" title="查看本地已添加的远程仓库"></a>查看本地已添加的远程仓库</h2><pre><code class="git">    git remote show</code></pre><h2 id="查看指定的本地关联的远程仓库remote地址，远程分支，还有本地分支与之相对应关系"><a href="#查看指定的本地关联的远程仓库remote地址，远程分支，还有本地分支与之相对应关系" class="headerlink" title="查看指定的本地关联的远程仓库remote地址，远程分支，还有本地分支与之相对应关系"></a>查看指定的本地关联的远程仓库remote地址，远程分支，还有本地分支与之相对应关系</h2><pre><code class="git">    git remote show [origin]</code></pre><h2 id="与指定远程仓库分支比较，删除本地多余的分支"><a href="#与指定远程仓库分支比较，删除本地多余的分支" class="headerlink" title="与指定远程仓库分支比较，删除本地多余的分支"></a>与指定远程仓库分支比较，删除本地多余的分支</h2><pre><code class="git">    git remote prune [origin]</code></pre><h1 id="进阶魔法"><a href="#进阶魔法" class="headerlink" title="进阶魔法"></a>进阶魔法</h1><h2 id="git-marge-合并分支"><a href="#git-marge-合并分支" class="headerlink" title="git marge 合并分支"></a><font style="background:yellow">git marge</font> 合并分支</h2><pre><code class="git">    // 我们首先切换到master分支，    git checkout master    // 然后我们在将feature/A 分支合并到master分支    git marge --no-ff feature/A    // 注意这里为了明确本次合并记录需要加上--no-ff 随后会出现编辑器编辑完成保存提交就完成啦</code></pre><h2 id="git-log-–graph-以图表的形式查看分支"><a href="#git-log-–graph-以图表的形式查看分支" class="headerlink" title="git log –graph 以图表的形式查看分支"></a><font style="background:yellow">git log –graph</font> 以图表的形式查看分支</h2><p>以图表的形式输出更清晰，务必记住该命令</p><pre><code class="git">    git log --graph    * commit 83b0b94268675cb715ac6c8a5bc1965938c15f62    |\ Merge: fd0cbf0 8a6c8b9    | | Author: hirocaster &lt;hohtsuka@gmail.com&gt;    | | Date: Sun May 5 16:37:57 2013 +0900    | |    | | Merge branch &#39;feature-A&#39;    | |    | * commit 8a6c8b97c8962cd44afb69c65f26d6e1a6c088d8    |/ Author: hirocaster &lt;hohtsuka@gmail.com&gt;    | Date: Sun May 5 16:22:02 2013 +0900    |    | Add feature/A    |    * commit fd0cbf0d4a25f747230694d95cac1be72d33441d    | Author: hirocaster &lt;hohtsuka@gmail.com&gt;    | Date: Sun May 5 16:10:15 2013 +0900    |    | Add index    |    * commit 9f129bae19b2c82fb4e98cde5890e52a6c546922    Author: hirocaster &lt;hohtsuka@gmail.com&gt;    Date: Sun May 5 16:06:49 2013 +0900    First commit</code></pre><h2 id="git-reset-回溯历史版本"><a href="#git-reset-回溯历史版本" class="headerlink" title="git reset 回溯历史版本"></a><font style="background:yellow">git reset</font> 回溯历史版本</h2><p>之前我们学习的都是完成功能后提交代码，git的另一特性就现的更灵活。那就是可回溯代码。<br>示例：在master之前合并了feature/A分支，我们想要回到合并之前的代码。<br>要完全恢复到之前的代码，我们需要拿到目标时间点的哈希值(即提交的commitId)</p><pre><code class="git">    git reset --hard fd0cbf0d4a25f747230694d95cac1be72d33441d</code></pre><h2 id="git-reflog-查看当前仓库执行过的操作的日志"><a href="#git-reflog-查看当前仓库执行过的操作的日志" class="headerlink" title="git reflog 查看当前仓库执行过的操作的日志"></a>git reflog 查看当前仓库执行过的操作的日志</h2><p>在日志中，我们可以看到 commit、checkout、reset、merge 等 Git 命<br>令的执行记录。只要不进行 Git 的 GC（Garbage Collection，垃圾回收），<br>就可以通过日志随意调取近期的历史状态，就像给时间机器指定一个时<br>间点，在过去未来中自由穿梭一般。</p><pre><code class="git">    git reflog</code></pre><h2 id="遇到冲突如何解决"><a href="#遇到冲突如何解决" class="headerlink" title="遇到冲突如何解决"></a>遇到冲突如何解决</h2><p>在我们执行git marge –no-ff feature/A 后，出现了冲突，<br>解决办法：我们打开编辑器，查看有冲突的地方，编辑后再次提交到feature/A分支，再次执行合并请求<br>冲突就解决了啦~。</p><h2 id="如果我们对上一次的提交描述不满意怎么办"><a href="#如果我们对上一次的提交描述不满意怎么办" class="headerlink" title="如果我们对上一次的提交描述不满意怎么办"></a>如果我们对上一次的提交描述不满意怎么办</h2><p>使用 git commit –amend<br>执行上面的命令后会出现编辑器，修改我们之前的描述，保存提交就可以啦~<br>使用 git log –graph 查看提交，修改就成功啦</p><h2 id="git-rebase-i-压缩历史提交"><a href="#git-rebase-i-压缩历史提交" class="headerlink" title="git rebase -i 压缩历史提交"></a>git rebase -i 压缩历史提交</h2><p>如果我们提交了两次代码到本地仓库，然后发现第一次提交的描述有错误的地方，我们可以这样做。<br>使用git rebase -i HEAD~2 命令<br>执行后会出现编辑器，显示如下</p><pre><code class="git">pick 7a34294 第二次提交描述pick 6fba227 第一次提交描述# Rebase 2e7db6f..6fba227 onto 2e7db6f## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like &quot;squash&quot;, but discard this commit&#39;s log message# x, exec = run command (the rest of the line) using shell## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out</code></pre><p>我直接讲第一次描述 6fba227 压缩到第二次提交描述(7a34294)中，修改第一次描述提交(6fba227)前的（pick）为（fixup）.<br>保存并关闭编辑器，系统提示rebase成功，那压缩就完成啦~<br>我们在使用 git log –graph 查看，发现我们第二次提交的commitId已经发生了改变，而第一次提交则别完全抹除掉了。</p><h2 id="git-remote-add-添加远程仓库"><a href="#git-remote-add-添加远程仓库" class="headerlink" title="git remote add 添加远程仓库"></a>git remote add 添加远程仓库</h2><pre><code class="git">    git remote add origin [仓库地址]</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入了解http</title>
    <link href="/2020/02/05/http/"/>
    <url>/2020/02/05/http/</url>
    
    <content type="html"><![CDATA[<p>作为一名web开发人员，http是每天都会和我们打交道的，今天就来深度学习下http的相关知识。我将从下面几个方面学习：<br>1、认识http；2、http的优缺点；3、http请求响应的过程；4、http请求特征；5、http报文；6、与http相关的组件；7、与http相关的协议；</p><h2 id="认识http"><a href="#认识http" class="headerlink" title="认识http"></a>认识http</h2><p>对http最常见的说法是：http是一种 <font color="#FF6A6A">超文本传输协议(Hypertext Transfer Protocol)</font>;文字拆分的也就是：超文本(Hypertext)、传输(Transfer)、协议(Protocol);他们之间的关系是这样的：按范围大小 协议 &gt; 传输 &gt; 超文本；下面分别对他们进行认识。</p><h3 id="什么是超文本"><a href="#什么是超文本" class="headerlink" title="什么是超文本"></a>什么是超文本</h3><p>早期我们的信息只能存储无法与其他电脑进行交互。我们保存的信息一般是以文本(简单字符)的形式存在，随着互联网的高速发展，两台电脑的数据实现传输后，人们开始不满足于两台电脑的文字传输，还想要实现图片、视频、音频，甚至是点击一个文字或图片能够进行<font color="#FF6A6A">超链接</font>的跳转，文本的语义就由此被扩大，这种语义被扩大后的文本就被称为<font color="#FF6A6A">超文本</font>.</p><h3 id="什么是传输"><a href="#什么是传输" class="headerlink" title="什么是传输"></a>什么是传输</h3><p>上面有说到两台电脑之间会形成互联关系进行通信；那我们将存储的超文本被解析成二进制数据包，由传输载体负责把二进制数据包从计算机终端传输到另一个终端的过程成为传输(Transfer).<br>通常我们将传输二进制数据包的一方称为<font color="#FF6A6A">请求方</font>，将接受二进制数据包的一方称为<font color="#FF6A6A">应答方</font>。请求方和接受方可以进行互换身份，请求方也可成为接受方，接受方也可成为请求方。</p><pre><code class="bash">            A                           B            |         A请求B            |            | ------------------------→ |            |         B响应A            |            | ←------------------------ |            |                           |            |         B请求A            |            | ←------------------------ |            |         A响应B            |            | ------------------------→ |            |                           |            ↓                           ↓</code></pre><h3 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h3><p>协议并不是只存在于互联网范畴，也体现在日常生活中，比如情侣双方约定好在那里吃饭，这也是一种协议，比如你应聘成功了，企业会和你签订劳动合同，这种双方的雇佣关系也是一种协议。自己一个人对自己的约定不能算是协议，协议的前提条件是必须多人约定。</p><p>那么网络协议是什么呢？</p><p>网络协议就是网络中（互联网）传递、管理信息的一些规范。如同人与人之间交流也应该遵循一定规矩一样。计算机之间也同样应该共同遵循一定的规则，这些规则就成为网络协议。</p><p>总结一下：http是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。</p><h2 id="http的优缺点"><a href="#http的优缺点" class="headerlink" title="http的优缺点"></a>http的优缺点</h2><h3 id="http的优点"><a href="#http的优点" class="headerlink" title="http的优点"></a>http的优点</h3><p>简单灵活易扩展<br>Http最重要也是最突出的优点就是 <b>简单、灵活、易扩展</b>。<br>http的协议比较简单，它组要由header、body部分组成。头部信息也是简单的文本格式。在简单的基础上，Http协议又多了灵活和易扩展的优点。Http协议里面的请求方法、URI、状态码、原因短语、头字段等每个核心组成要素都没有限制死，允许开发者任意定制、扩充或解释，给予了浏览器和服务器最大的信任和自由。</p><h4 id="应用广泛，环境成熟。"><a href="#应用广泛，环境成熟。" class="headerlink" title="应用广泛，环境成熟。"></a>应用广泛，环境成熟。</h4><p>因为简单的特性，而被广泛的应用。Http并不是什么编程的语言，所以天然的具有跨平台、跨语言的优越性。<br>随着互联网的发展，Http已经延伸到了世界的每一个角落，从简单的web页面到复杂的JSON、XML数据，还有各种app上面、新闻、论坛、手机游戏等，应用非常之广泛。</p><h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>无状态其实既是优点也是缺点。因为服务器没有记忆能力，所以就不需要额外的资源来记录状态信息，不仅实现简单，还能减轻服务器的负担。</p><h3 id="http的缺点"><a href="#http的缺点" class="headerlink" title="http的缺点"></a>http的缺点</h3><h4 id="无状态-1"><a href="#无状态-1" class="headerlink" title="无状态"></a>无状态</h4><p>既然服务器没有记忆能力，它就无法支持需要连续多步骤的事务操作。每次都需问一次身份信息，不仅麻烦还增加了不必要的数据传输。为此出现了cookie技术，之后又延伸出session技术。</p><h4 id="明文"><a href="#明文" class="headerlink" title="明文"></a>明文</h4><p>Http协议里面还有一把优缺点一体的双刃剑，就是明文传输。明文就是协议里面的报文（header部分）不使用二进制数据，而是用简单可阅读的文本形式。<br>对比Tcp、Udp这样的二进制协议，它的优点显而易见，不需要借助任何外部工具，用浏览器、Wireshark或者tcpdump抓包后，直接就可以查看修改，为我们的开发调试工作带来了便利。<br>缺点也就显而易见了，能够被任意查看，带来的安全性大大降低。</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>Http性能不是特别差，但不完全适应现在的互联网，还有很大的提升。</p><h2 id="http请求响应的过程"><a href="#http请求响应的过程" class="headerlink" title="http请求响应的过程"></a>http请求响应的过程</h2><p>请求响应的过程就如同用户从浏览器输入地址到之后发生一系列事件的一个过程。。<br>那我们在浏览器上输入地址后到底发生了什么呢？ 马上来学习下。<br>    1、DNS服务器会优先进行域名的映射，找到刚刚输入的地址，然后Http客户端相应端口（默认是80）发起一个到服务器的TCP连接请求。在客户与服务器进程中都有一个套接字与其相连。(这里相当于浏览器请求DNS服务器查询这个域名的IP地址，然后DNS返回这个域名的IP给到浏览器)<br>    2、Http客户端会通过这个套接字向服务端发起一个Http报文。这个报文就包含了请求路径，请求参数等。<br>    3、Http服务器通过这个套接字接受该报文，进行请求解析工作，并从其存储器中检索出资源，然后将检索出的资源封装，封装到Http的响应报文中，并通过套接字向客户端进行发送。<br>    4、Http服务器开始通知TCP断开连接，这时候TCP不会真的断开连接，开始等待客户端接受响应报文，然后TCP主动断开连接。<br>    5、Http客户端接受到来着服务端的报文后，提取里面的响应文件（html文件）并检查该文件，然后循环检查报文中其他内部对象。<br>    6、检查完成后会将html文件渲染到客户端呈现在用户面前。</p><h2 id="http请求特征"><a href="#http请求特征" class="headerlink" title="http请求特征"></a>http请求特征</h2><p>通过上面的响应过程可以发现有如下特征：<br>    1、支持客户-服务端模式<br>    2、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。<br>    3、灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由<font color="#FF6A6A"> Content-Type </font>加以标记。<br>    4、无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。<br>    5、无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p><h2 id="http报文"><a href="#http报文" class="headerlink" title="http报文"></a>http报文</h2><p>HTTP 协议主要由三大部分组成：<br>    1、起始行（start line）：描述请求或响应的基本信息；<br>    2、头部字段（header）：使用 key-value 形式更详细地说明报文；<br>    3、消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据；<br><br/><br>    其中起始行和头部字段并成为 请求头 或者 响应头，统称为 Header；消息正文也叫做实体，称为 body。HTTP 协议规定每次发送的报文必须要有 Header，但是可以没有 body，也就是说头信息是必须的，实体信息可以没有。而且在 header 和 body 之间必须要有一个空行（CRLF）</p><h2 id="与http相关的组件"><a href="#与http相关的组件" class="headerlink" title="与http相关的组件"></a>与http相关的组件</h2><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p>网络是一个复杂的系统，不仅包括大量的应用程序、端系统、通信链路、分组交换机等，还有各种各样的协议组成，那么现在我们就来聊一下网络中的协议层次。<br>为了给网络协议的设计提供一个结构，网络设计者以<font color="#FF6A6A">分层(layer)</font>的方式组织协议，每个协议属于层次模型之一。每一层都是向它的上一层提供<font color="#FF6A6A">服务(service)</font>，即所谓的<font color="#FF6A6A">服务模型(service model)</font>。每个分层中所有的协议称为<font color="#FF6A6A"> 协议栈(protocol stack)</font>。因特网的协议栈由五个部分组成：物理层、链路层、网络层、运输层和应用层。我们采用自上而下的方法研究其原理，也就是应用层 -&gt; 物理层的方式。</p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层是网络应用程序和网络协议存放的分层，因特网的应用层包括许多协议，例如我们学 web 离不开的 HTTP，电子邮件传送协议 <font color="#FF6A6A">SMTP</font>、端系统文件上传协议 <font color="#FF6A6A">FTP</font>、还有为我们进行域名解析的 <font color="#FF6A6A">DNS </font>协议。应用层协议分布在多个端系统上，一个端系统应用程序与另外一个端系统应用程序交换信息分组，我们把位于应用层的信息分组称为<font color="#FF6A6A"> 报文(message)</font>。</p><h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h4><p>因特网的运输层在应用程序断点之间传送应用程序报文，在这一层主要有两种传输协议 <font color="#FF6A6A">TCP 和 UDP</font>，利用这两者中的任何一个都能够传输报文，不过这两种协议有巨大的不同。</p><p>TCP 向它的应用程序提供了面向连接的服务，它能够控制并确认报文是否到达，并提供了拥塞机制来控制网络传输，因此当网络拥塞时，会抑制其传输速率。<br>UDP 协议向它的应用程序提供了无连接服务。它不具备可靠性的特征，没有流量控制，也没有拥塞控制。我们把运输层的分组称为 报文段(segment)</p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>因特网的网络层负责将称为 <font color="#FF6A6A">数据报(datagram)</font> 的网络分层从一台主机移动到另一台主机。网络层一个非常重要的协议是 IP 协议，所有具有网络层的因特网组件都必须运行 IP 协议，IP 协议是一种网际协议，除了 IP 协议外，网络层还包括一些其他网际协议和路由选择协议，一般把网络层就称为 IP 层，由此可知 IP 协议的重要性。</p><h4 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h4><p>现在我们有应用程序通信的协议，有了给应用程序提供运输的协议，还有了用于约定发送位置的 IP 协议，那么如何才能真正的发送数据呢？为了将分组从一个节点（主机或路由器）运输到另一个节点，网络层必须依靠链路层提供服务。链路层的例子包括以太网、WiFi 和电缆接入的 <font color="#FF6A6A">DOCSIS 协议</font>，因为数据从源目的地传送通常需要经过几条链路，一个数据包可能被沿途不同的链路层协议处理，我们把链路层的分组称为 帧(frame)</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>虽然链路层的作用是将帧从一个端系统运输到另一个端系统，而物理层的作用是将帧中的一个个 比特 从一个节点运输到另一个节点，物理层的协议仍然使用链路层协议，这些协议与实际的物理传输介质有关，例如，以太网有很多物理层协议：关于双绞铜线、关于同轴电缆、关于光纤等等。</p><h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><p>我们上面讨论的计算网络协议模型不是唯一的 协议栈，ISO（国际标准化组织）提出来计算机网络应该按照7层来组织，应用层-》表示层-》会话层-》运输层-》网络层-》链路层-》物理层<br>OSI 要比上面的网络模型多了 <font color="#FF6A6A">表示层</font> 和 <font color="#FF6A6A">会话层</font>，其他层基本一致。表示层主要包括数据压缩和数据加密以及数据描述，数据描述使得应用程序不必担心计算机内部存储格式的问题，而会话层提供了数据交换的定界和同步功能，包括建立检查点和恢复方案。</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>CDN的全称是Content Delivery Network，即<font color="#FF6A6A">内容分发网络</font>，它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。CDN 是构建在现有网络基础之上的网络，它依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户<font color="#FF6A6A">就近</font>获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有<font color="#FF6A6A">内容存储和分发技术</font>。</p><h3 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h3><p>WAF 是一种 Web 应用程序防护系统（Web Application Firewall，简称 WAF），它是一种通过执行一系列针对HTTP / HTTPS的安全策略来专门为Web应用提供保护的一款产品，它是应用层面的<font color="#FF6A6A">防火墙</font>，专门检测 HTTP 流量，是防护 Web 应用的安全技术。</p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><h2 id="与Http相关的协议"><a href="#与Http相关的协议" class="headerlink" title="与Http相关的协议"></a>与Http相关的协议</h2><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇。TCP/IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， 只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>域名系统（服务）协议（DNS）是一种分布式网络目录服务，主要用于域名与 IP 地址的相互转换，以及控制因特网的电子邮件的发送.</p><h3 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI/URL"></a>URI/URL</h3><p>URI的全称是（Uniform Resource Identifier），中文名称是统一资源标识符，使用它就能够唯一地标记互联网上资源。<br>URL的全称是（Uniform Resource Locator），中文名称是统一资源定位符，也就是我们俗称的网址，它实际上是 URI 的一个子集<br>URI 不仅包括 URL，还包括 URN（统一资源名称）</p><h3 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h3><p>HTTP 一般是明文传输，很容易被攻击者窃取重要信息，鉴于此，HTTPS 应运而生。HTTPS 的全称为 （Hyper Text Transfer Protocol over SecureSocket Layer），全称有点长，HTTPS 和 HTTP 有很大的不同在于 HTTPS 是以安全为目标的 HTTP 通道，在 HTTP 的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPS 在 HTTP 的基础上增加了 SSL 层，也就是说 HTTPS = HTTP + SSL</p>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初衷</title>
    <link href="/2019/12/05/initial/"/>
    <url>/2019/12/05/initial/</url>
    
    <content type="html"><![CDATA[<p>终于把属于<a href="https://anlex-push.github.io">自己的博客</a>建好了，也是我第一次建博客，希望在新的一年能很好的提升自己的写作能力，同时记录自己的学习成长路线、一些经验等。希望在新的一年里能收获的更多。</p><h2 id="关于初衷"><a href="#关于初衷" class="headerlink" title="关于初衷"></a>关于初衷</h2><p>成立博客的初衷就是想要记录自己的生活、技术成长、其他能力提升，为更好的自己而奋斗。</p><h2 id="2019年简单总结"><a href="#2019年简单总结" class="headerlink" title="2019年简单总结"></a>2019年简单总结</h2><p>2019年收获了很多，收获和同事之间的友谊；收获了爱情，找到了那个她；技术上也得到了一些提升，很感谢同事对我的认可和帮助；2019年总的来说过的很“充实”，同时也发现了自己许多的不足。</p><h3 id="沟通能力上"><a href="#沟通能力上" class="headerlink" title="沟通能力上"></a>沟通能力上</h3><p>在工作中沟通往往是最重要的，有时get不到别人的意思是真的很着急。在一次和运营确定需求后，运营频繁更改需求，也就是出现了需求刚还是确定的很模糊，到了后面不断沟通才确定需求的细节。自己对需求可能也没有理解到；在项目开始之前就应获取到运营的需求文档并仔细阅读。</p><h3 id="技术能力"><a href="#技术能力" class="headerlink" title="技术能力"></a>技术能力</h3><p>在许多项目进行下来发现自己对react及js的知识开始有所遗忘，根本的原因还是在自身没有很好的巩固和复习。目前的项目框架版本过多，许多项目都用的不同版本，过多版本的代码切换有一点心累。对于Linux盒子的兼容问题还是要做一套服务端渲染的版本，但这个得一步一步的来，路漫漫其修远兮。。</p><h3 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h3><p>19年的8月10号认识了你，想起那时的你还是那么可爱，有时又有一点害羞，工作起来也是那么的可爱。和你相识也快有半年了，我真的想和你一直走下去，我知道前面肯定有许都阻碍，但我一定会努力。对于我的衣品是真的差，有了你之后开始注意到这一点，多一个人的关心，我真的很幸福。</p><h3 id="新的一年希望努力成为更好的自己"><a href="#新的一年希望努力成为更好的自己" class="headerlink" title="新的一年希望努力成为更好的自己"></a>新的一年希望努力成为更好的自己</h3><h2 id="新一年的规划"><a href="#新一年的规划" class="headerlink" title="新一年的规划"></a>新一年的规划</h2><p>今天的太阳很活泼，阳光照在脸上有一丝丝的暖意；中国加油！武汉加油！！</p><h3 id="技术提升"><a href="#技术提升" class="headerlink" title="技术提升"></a>技术提升</h3><p>前端的技术核心莫过于JavaScript;<br>1、每天阅读关于js的文章一篇（来源任何平台）。<br>2、每天练习一道js算法题。<br>3、了解一些关于react的一些新动向。<br>4、持之以恒，不要拖沓。</p><h3 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h3><p>磨练自己的心细，遇事不要太着急，仔细倾听别人是怎么说的，不懂的及时交流。性格也要努力改变，活泼开朗一点，多与人沟通。</p><h3 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h3><p>你不理财，财不理你！ 不知道在那里听到的这句话，但觉得还是有点道理。去年是真的没有存到什么钱，不知道钱都花到那里去了。是时候计划下理财了。<br>1、努力存钱，每个月定期存收入的50%。<br>2、每天投入10块到靠谱基金，合理分配自己的资产，及时止损。</p><h3 id="努力更新博客提升自己"><a href="#努力更新博客提升自己" class="headerlink" title="努力更新博客提升自己"></a>努力更新博客提升自己</h3>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
